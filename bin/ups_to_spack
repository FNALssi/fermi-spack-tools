#!/usr/bin/env python

import os
import sys
import re
import os.path
import logging
import glob
import traceback

# we want to use the ruamel.yaml package from spack
sys.path.insert(1, "%s/lib/spack/external" % os.environ["SPACK_ROOT"])
sys.path.insert(1, "%s/lib/spack" % os.environ["SPACK_ROOT"])
import ruamel.yaml


def log_call(f):
    """ decorator to log calls to functions at debug level """

    def logged(*args, **kwargs):
        logging.debug("entering %s%s%s" % (f.__name__, repr(args), repr(kwargs)))
        res = f(*args, **kwargs)
        logging.debug("leaving %s returning %s" % (f.__name__, repr(res)))
        return res

    return logged


def remember(f):
    def wrap(self, *args, **kwargs):
        if not " _memory" in self.__dict__:
            self._memory = {}
        if not f.__name__ in self._memory or not self._memory[f.__name__]:
            self._memory[f.__name__] = f(self, *args, **kwargs)
        return self._memory[f.__name__]

    return wrap


def spack_reindex():
    """ 
        run spack reindex, 
        pick the hash value from the first 'No such file or directory' error
        and return it -- this is Really Important, because this is how
        this script discovers hash values for packages.
    """
    logging.debug("spack_reindex")
    f = os.popen("spack reindex 2>&1", "r")
    for line in f:
        if line.find("No such file or directory") > 0:
            logging.debug("saw error line: %s" % line)
            res = line.replace("'", "").strip()
            logging.debug("res now(1): %s" % res)
            m = re.match(".*?(/.*)-(.*)", res)
            f.close()
            if m:
                return m.group(1), m.group(2)

    f.close()
    return "", ""


def ups_depend(prod, ver, flav, qual, hosttype=''):
    """ run ups depend, return list of output lines """
    return ups_x("depend", prod, ver, flav, qual, hosttype)

def canon_quals(qual):
    ll = qual.split(":")
    ll.sort()
    return ":".join(ll)

def ups_x(what, prod, ver, flav, qual, hosttype=''):
    """ run ups what, return list of output lines """

    # we've gotten some weird things from bugs upstream,
    # so try to capture where they come from...
    if qual:
        qual = qual.strip()
    if flav:
        flav = flav.strip()
    if qual == "-q":
        logging.error("Ouch! got a -q for qualifier!")
        traceback.print_stack()
        qual = ""

    if flav and flav[0] not in "NLD":
        logging.error("Ouch! got '%s' for flavor!")
        traceback.print_stack()
        flav = ""

    cmd = "ups %s %s %s %s %s %s %s %s %s 2>/dev/null" % (
        what,
        prod,
        ver,
        "-f" if flav else "",
        flav,
        "-q" if qual else "",
        qual,
        "-H" if hosttype else "",
        hosttype,
    )

    logging.debug("ups_x: cmd: %s" % cmd)
    f = os.popen(cmd, "r")
    res = f.readlines()
    f.close()
    return res


class outfile:
    """ 
       class for a module output file -- tcl or lmod 
       like a regular file, but makes intervening directories, and
       has enable/disable for actually writing

    """

    def __init__(self, fname, flag="w"):
        self.generating = False
        self.skip = False
        self.depth = 0
        self.fname = fname
        if not os.access(os.path.dirname(fname), os.R_OK):
            os.makedirs(os.path.dirname(fname))
        if flag == "a":
            logging.debug("outfile.__init__: append for %s..." % fname)
            if not os.path.exists(fname):
                self.skip = True
                return
            # this sort of breaks the wall, but we share the recipe
            # file for  multiple instances, so check if we've already
            # done this one...
            f = open(fname,"r")
            for line in f:
                if line.find("def setup_run_environment") > 0:
                    logging.debug("outfile.__init__: Already did table file for %s..." % fname)
                    self.skip = True
            f.close()
            if self.skip:
                return
        self.outf = open(fname, flag)
        logging.debug("outfile.__init__: opened: %s" % fname)
        self.depth_increase_patterns=["{","function","then"]
        self.depth_decrease_patterns=["}","end"]
        self.setup_patterns = ["proc setup {} {","function setup ()","def tf_setup"]
        self.saw_setup = False

    def enable(self):
        if self.skip:
            return 
        logging.debug("enabling: %s" % self.fname)
        self.generating = True

    def disable(self):
        logging.debug("disabling: %s" % self.fname)
        self.generating = False

    def write(self, text):
        indenting = 0
        if self.generating:
            logging.debug("considiring writing %s" % text)
            for pat in self.depth_increase_patterns:
                logging.debug("depth: checking for %s" % pat)
                p2=text.find(pat)
                if p2 > 0 and pat[0] in ['t','f'] and text[p2-1] not in [' ','{']:
                    # do not match end in Prepend, etc.
                    break
                while p2 >= 0:
                    logging.debug("depth: saw %s at %s" % (pat, p2))
                    p2=text.find(pat,p2+1)
                    self.depth = self.depth + 1
                    indenting = 1

            for pat in self.depth_decrease_patterns:
                logging.debug("depth: checking for %s" % pat)
                p2=text.find(pat)
                if p2 > 0 and pat == 'end' and text[p2-1] != ' ':
                    # do not match end in Prepend, etc.
                    break
                while p2 >= 0:
                    logging.debug("depth: saw %s at %s" % (pat, p2))
                    p2=text.find(pat,p2+1)
                    self.depth = self.depth - 1

            for pat in self.setup_patterns:
                if text.find(pat) >= 0:
                    self.saw_setup = True

            if text in ["setup","setup();"]:
                if not self.saw_setup:
                    logging.debug("not writing setup call without definition")
                     
            if self.depth >= 0:
                # auto indent -- needed? mengel --definitely for python..
                text = ("  " * (self.depth - indenting)) + text

                logging.debug("writing on %d %s text: %s" % (self.depth, self.fname, text))
                self.outf.write(text)
            else:
                logging.debug("not writing on %s text: %s" % (self.fname, text))
                # don't write what would send us under, but don't stick there..
                self.depth = 0

    def close(self):
        if self.skip:
            return
        self.outf.close()
        self.depth = 0

class package:
    def __init__(
        self,
        depline=None,
        kline=None,
        top_flav=None,
        top_quals=None,
        depth=0,
        prod=None,
        ver=None,
        flav=None,
        quals=None,
    ):
        self.top_flav = top_flav
        self.top_quals = top_quals
        self.depth = depth
        self.namespace = None
        if depline:
            depline = depline.lstrip("|_ ").rstrip()
            ll = depline.split(" ")
            self.prod, self.ver, fflag, self.flav, qflag, self.quals = ll[:6]

            if qflag != "-q":
                if qflag == "-z" and len(ll) > 6 and ll[6] == "-q":
                    self.quals =  ll[7]
                else:
                    self.quals = ""

            self.prod_dir = None
            self.table_file = None

        elif kline:
            kline = kline.strip().replace('"', "")
            ll = kline.split(" ")
            self.prod, self.ver, self.flav, self.quals, self.prod_dir, self.table_file = ll[:7]
        else:
            self.prod = prod
            self.ver = ver
            self.flav = flav
            self.quals = quals
            self.prod_dir = None
            self.table_file = None

        if self.quals == "-q":
            logging.error("Ouch! got a -q for qualifier!")
            traceback.print_stack()
            self.quals = ""

    def __str__(self):
        return "%s %s -f %s -q '%s' top: -f %s -q '%s' depth %s" % (
            self.prod,
            self.ver,
            self.flav,
            self.quals,
            self.top_flav,
            self.top_quals,
            self.depth,
        )

    def __repr__(self):
        return "<Package %s>" % self.__str__()

    def default_flavor(self, f_os):
        if f_os[:3] == "Dar":
            return "Darwin64bit+16.7.0"
        if f_os[:3] == "Lin":
            return "Linux64bit+3.10-2.17"
        return "Linux64bit+3.10-2.17"

    @remember
    @log_call
    def spack_arch(self):

        self.topbits()

        l1 = re.split("[- +]*", self.top_flav)
        logging.debug("l1: %s" % repr(l1))
        f_os = l1[0]
        f_osrel = l1[1] if len(l1) > 1 else ""
        f_libc = l1[2] if len(l1) > 2 else ""
        f_dist = l1[3] if len(l1) > 3 else ""

        if f_os == "NULL":
            f_os = ""

        l2 = re.split("[- +]*", self.default_flavor(f_os))
        logging.debug("l2: %s" % repr(l2))
        f_os = f_os if f_os else l2[0]
        f_osrel = f_osrel if f_osrel else l2[1] if len(l2) > 1 else ""
        f_libc = f_libc if f_libc else l2[2] if len(l2) > 2 else ""
        f_dist = f_dist if f_dist else l2[3] if len(l2) > 3 else ""

        tf_1 = f_os.lower().replace("64bit", "")

        tf_2 = "%s-%s" % (f_osrel, f_libc)

        if f_os[:3] == "Dar":
            tf_2 = re.sub("13[-.].*", "mavericks", tf_2)
            tf_2 = re.sub("14[-.].*", "yosemite", tf_2)
            tf_2 = re.sub("15[-.].*", "elcapitan", tf_2)
            tf_2 = re.sub("16[-.].*", "sierra", tf_2)
            tf_2 = re.sub("17[-.].*", "highsierra", tf_2)
            tf_2 = re.sub("18[-.].*", "mojave", tf_2)
            tf_2 = re.sub("^[0-9].*", "yosemite", tf_2)

        if f_os[:3] == "Lin":
            tf_2 = re.sub(".*-2.17", "scientific7", tf_2)
            tf_2 = re.sub(".*-2.12", "scientificfermi6", tf_2)
            tf_2 = re.sub(".*-2.6", "scientificfermi5", tf_2)
            tf_2 = re.sub("^[0-9].*", "scientificfermi5", tf_2)

        # excessive intel-centrism...
        if f_os.find("64bit") > 0:
            tf_3 = "x86_64"
        else:
            tf_3 = "i386"

        logging.debug("spack_arch(%s) -> %s-%s-%s" % (self.flav, tf_1, tf_2, tf_3))
        return "%s-%s-%s" % (tf_1, tf_2, tf_3)

    @remember
    def upslistargs(self):
        return "%s %s -f %s -q '%s'" % (self.prod, self.ver, self.flav, self.quals)

    @remember
    def dependlines(self, hosttype = None):
        if not hosttype:
            hosttype = self.top_flav
        dependlines = ups_depend(self.prod, self.ver, self.flav, self.quals, hosttype=hosttype )

        #
        # kluge for ifhdc -q python2[67]... add a python dependency
        #
        if self.quals[:6] == "python":
            logging.debug("saw python* quals: %s" % self.quals)
            vers= "v%s_%s_2" % (self.quals[6], self.quals[7])
            pylines = ups_depend("python", vers, "", "", hosttype=hosttype)
            if pylines:
                dependlines.append("|__%s" % pylines[0])

        return dependlines

    # utilities to flesh out useful bits we might not have...

    def prodbits(self):
        if self.table_file == None:
            res = ups_x("list", "-K@prod_dir:@table_file", self.upslistargs(), "", "")
            logging.debug("prod_dir etc returns: %s" % repr(res))
            if res:
                ll = res[0].strip().replace('"', "").split(" ")
                logging.debug("prod_dir etc splt: %s" % repr(ll))
                self.prod_dir = ll[0]
                self.table_file = ll[1]

    def topbits(self):
        if self.top_quals == None and self.top_flav == None:
            self.top_quals = self.quals
            self.top_flav = self.flav

        if self.top_flav == "NULL":
            raise AssertionError("Should not have a NULL top flavor!")

        if self.ver:
            self.dotver = self.ver.replace("v", "").replace("b", "").replace("_", ".")

    @log_call
    def spack_comp(self, splitpart = -1):
        self.topbits()
        res = "gcc-4.1.1"  # sl5 compiler by default??
        if self.top_flav.find("2.17") >= 0:
            res = "gcc-4.8.5"
        if self.top_flav.find("2.12") >= 0:
            res = "gcc-4.4.7"
        if self.top_quals.find("c7") >= 0:
            res = "clang-7.0.0"
        if self.top_quals.find("c2") >= 0:
            res = "clang-5.0.1"
        if self.top_quals.find("e19") >= 0:
            res= "gcc-8.2.0"
        if self.top_quals.find("e18") >= 0:
            res= "gcc-7.3.0"
        if self.top_quals.find("e17") >= 0:
            res = "gcc-7.3.0"
        if self.top_quals.find("e15") >= 0:
            res = "gcc-6.4.0"
        if self.top_quals.find("e14") >= 0:
            res = "gcc-6.3.0"
        if self.top_quals.find("e10") >= 0:
            res = "gcc-4.9.3"
        if self.top_quals.find("e7") >= 0:
            res = "gcc-4.9.2"
        if self.top_quals.find("e6") >= 0:
            res = "gcc-4.9.1"
        if self.top_quals.find("e5") >= 0:
            res = "gcc-4.8.2"
        if self.top_quals.find("e4") >= 0:
            res = "gcc-4.8.1"
        if splitpart == -1:
            return res
        else:
            return res.split("-")[splitpart]


class ups_to_spack:
    def __init__(self, pdr=None):
        self.already_done = set()
        self.pkglist = None
        if pdr:
            ll = pdr.split("/")
            self.pdrn = int(ll[0])+1
            ll[0] = ''
            self.pdrl = ll
        else:
            self.pdrl = None
        self.all_flavors = (
            ("Darwin64bit+13.4.0", ""),
            ("Darwin64bit+14.5.0", ""),
            ("Darwin64bit+15.6.0", ""),
            ("Darwin64bit+16.7.0", ""),
            ("Linux64bit+2.6-2.5", ""),
            ("Linux64bit+2.6-2.12", ""),
            ("Linux64bit+3.10-2.17", ""),
        )
        self.cache_file = os.environ["SPACK_ROOT"] + "/var/ups_to_spack.cache"

    @log_call
    def get_cached_hash(self, pkg):
        pkg.topbits()
        sp_arch = pkg.spack_arch()
        thash = None
        if os.access(self.cache_file, os.R_OK):
            cf = open(self.cache_file, "r")
            pattern = ":".join(
                [pkg.prod, pkg.ver, pkg.top_flav, pkg.top_quals, sp_arch]
            )

            logging.debug("get_cached_hash: looking for: '%s'" % pattern)

            for line in cf:
                if line.find(pattern) == 0:
                    thash = line[(line.rfind(":") + 1) :]

                    thash = thash.strip()
                    break
            cf.close()
        return thash

    @log_call
    def add_cached_hash(self, pkg, thash):

        if pkg.top_flav in ("NULL", ""):
            raise AssertionError(
                "trying to add '%s' flavor product to cache" % pkg.top_flav
            )

        cf = open(self.cache_file, "a")
        cf.write(
            ":".join(
                [
                    pkg.prod,
                    pkg.ver,
                    pkg.top_flav,
                    pkg.top_quals,
                    pkg.spack_arch(),
                    thash,
                ]
            )
            + "\n"
        )
        cf.close()
 
    @log_call
    def migrate_one(self, pkg):
        if pkg in self.already_done:
            return

        self.already_done.add(pkg)

        # could have been done by a previous run...
        thash = self.get_cached_hash(pkg)

        if not thash:
            self.make_recipe(pkg)
            self.make_spec(pkg)
            thash = self.reindex_for_hash_and_rename(pkg)
            if thash:
                self.add_cached_hash(pkg, thash)
                self.convert_table(pkg, thash)
            else:
                logging.info("Warning: unable to get hash for pkg %s" % pkg)
        else:
            logging.debug("already done: %s" % pkg)

    @remember
    def get_repo_list(self):
        repolist = {}
        f = os.popen("spack repo list", "r")
        first=True
        for line in f.readlines():
           
            if first:
               first=False
               continue
            v = line.strip().split(" ")
            repolist[v[-1]] = v[0]
        f.close()
        return repolist



    @log_call
    def get_namespace(self, pkg):

        pkg.namespace = self.get_prod_namespace(pkg.prod)
        logging.debug("pkg %s namespace %s " % (pkg.prod, pkg.namespace))

    @remember
    def get_prod_namespace(self, prod):

        repolist = self.get_repo_list()

        for repo in repolist:
            pf = "%s/packages/%s/package.py" % (repo, prod)
            logging.debug("checking for %s..",pf)
            if os.access(pf , os.R_OK):
                return repolist[repo]
        return None

    @log_call
    def make_recipe(self, pkg):
        builtin_recipedir = "%s/var/spack/repos/builtin/packages/%s" % (
            os.environ["SPACK_ROOT"],
            pkg.prod,
        )
        uts_recipedir = "%s/var/spack/repos/ups_to_spack/packages/%s" % (
            os.environ["SPACK_ROOT"],
            pkg.prod,
        )
        
        uts_repo = "%s/var/spack/repos/ups_to_spack" % os.environ["SPACK_ROOT"]
        uts_repo_yaml = "%s/repo.yaml" % uts_repo
       

        # check that we have a ups_to_spack repository...
        if not os.access(uts_repo_yaml, os.R_OK):
            os.system("spack repo create %s ups_to_spack" % uts_repo)
            os.system("spack repo add --scope=default %s" % uts_repo )

        self.get_namespace(pkg)

        if (not pkg.namespace):

            # there has to be a recipe for the package for spack to
            # look at it, so make one that's (just) good enough to pass
            #
            # package names are BiCapitalized so fife_utils -> FifeUtils
            pkgname = pkg.prod.capitalize()
            pkgname = re.sub("_([a-z])", lambda m: m.group(1).capitalize(), pkgname)
            pkg.namespace = "ups_to_spack"

            if not os.access(uts_recipedir, os.R_OK):
                os.makedirs(uts_recipedir)
            recipe_f = open(uts_recipedir + "/package.py", "w")
            recipe_f.write("# fake recipe from ups_to_spack")
            recipe_f.write(
                "from spack import *\n\nclass %s(AutotoolsPackage):\n    pass\n"
                % pkgname
            )
            # recipe_f.close() -- no! do this later after adding dependencies
        else:
            recipe_f = None

        for line in pkg.dependlines():
            if re.match("^\\|__[a-z]", line):
                dpkg = package(depline=line, top_flav = pkg.top_flav, top_quals=pkg.top_quals)
                # if we're writing a recipe, add the dependency, to it
                if recipe_f:
                    recipe_f.write(
                        "    depends_on('%s', type=('build','run'))\n" % dpkg.prod
                    )

        if recipe_f:
            recipe_f.close()

    def do_pdr(self, path):
        if self.pdrl and path:
            dl = path.split("/")
            dl = self.pdrl + dl[self.pdrn:]
            dest = '/'.join(dl)
        else:
            dest = path
        return dest

    def get_spack_config(self, tag):
        """
           look up a line in the spack config 
        """
        sr = os.environ.get("SPACK_ROOT")
        for fn in [ "%s/etc/spack/config.yaml" % sr, "%s/etc/spack/defaults/config.yaml" % sr ]:
            try:
                f = open(fn, "r")
            except:
                continue

            for line in f.readlines():
                pos = line.find("%s:" % tag)
                if pos >= 0:
                    val = line[(pos + len(tag)+1):]
                    f.close()
                    return val.strip()
            f.close()
        return ""

    def get_basedir(self, pkg, thash = ""):

        # find our install path...
        install_tree = self.get_spack_config('install_tree').strip(' "')
        install_path_scheme = self.get_spack_config('install_path_scheme').strip(' "')
        basedir_fmt = "%s/%s" % (install_tree, install_path_scheme)

        #convert to %(name)s ...

        basedir_fmt = basedir_fmt.replace("${","%(" ).replace("}", ")s" )
        basedir_fmt = re.sub("\$([a-z][a-z_]*)", "%(\\1)s" , basedir_fmt)

        logging.debug("basedir_fmt %s " % (basedir_fmt))

        basedir = (basedir_fmt % {
            "spack": os.environ["SPACK_ROOT"],
            "ARCHITECTURE": pkg.spack_arch(),
            "COMPILERNAME": pkg.spack_comp(0),
            "COMPILERVER": pkg.spack_comp(1),
            "PACKAGE": pkg.prod,
            "VERSION": pkg.dotver,
            "HASH": thash,
        })

        
        logging.debug("basedir is now %s " % (basedir))
        return basedir

    def get_specfile(self, pkg):
        basedir = self.get_basedir(pkg)
        specfile = "%s/.spack/spec.yaml" % basedir
        return specfile

    @log_call
    def make_spec(self, pkg):
        """ 
           make the .spack/spec.yaml file and possibly a minimal recipe for 
           a given ups product.  This involves going through the ups dependencies
           of the package, adding the direct dependencies to the spec and 
           recipe, and adding all the dependencies to the spec.yaml file
           We use get_hash, above, to find the hash 
           We're using the yaml library from spack to write the .yaml file
           from a dictionary
        """

        # make sure our package is all filled out
        pkg.topbits()
        pkg.prodbits()

        basedir = self.get_basedir(pkg)
        specfile = self.get_specfile(pkg)

        if not os.access(os.path.dirname(specfile), os.R_OK):
            os.makedirs(os.path.dirname(specfile))

        # tag directory as being made by .ups_to_spack
        open("%s/.ups_to_spack" % basedir,"w").close()

        logging.debug("making symlinks in basedir %s from %s" % (basedir,pkg.prod_dir))
        # link in bin/ lib/ etc. dirs from ups directory so links paths might work
        if pkg.prod_dir:
            for d in glob.glob("%s/*" % pkg.prod_dir):
                if os.path.isdir(d):
                    try:
                        destbase = os.path.basename(d)
                        destdir = self.do_pdr(os.path.dirname(d))
                        logging.debug(" symlink(%s/%s, %s/%s)" % (destdir,destbase, basedir, destbase))
                        os.symlink("%s/%s" % (destdir,destbase), "%s/%s" % (basedir, destbase))
                    except:
                        logging.exception("do_pdr/symlink")
                        pass

        tfl = pkg.spack_arch().split("-")

        if not pkg.namespace:
            self.get_namespace(pkg)

        # create base spec file structure for the .yaml file writer
        spec = {
            "spec": [
                {
                    pkg.prod: {
                        "version": pkg.dotver,
                        "arch": {
                            "platform": tfl[0],
                            "platform_os": tfl[1],
                            "target": tfl[2],
                        },
                        "compiler": {
                            "name": pkg.spack_comp(0),
                            "version": pkg.spack_comp(1),
                        },
                        "namespace": pkg.namespace,
                        "parameters": {
                            "cppflags": [],
                            "cxxflags": [],
                            "ldflags": [],
                            "cflags": [],
                            "fflags": [],
                            "ldlibs": [],
                        },
                    }
                }
            ]
        }

        dependlines = pkg.dependlines()

        logging.debug("qualfiers: %s" % pkg.quals)
        logging.debug("dependlines: %s" % repr(dependlines))

        if len(dependlines) > 1:
            # only add a dependencies section if there are any dependencies
            spec["spec"][0][pkg.prod]["dependencies"] = {}

            dependlines = dependlines[1:]
            dependlines.reverse()

            for line in dependlines:
                if re.match("^\\|__[a-z]", line):
                    # it is an immediate dependency
                    logging.debug("immediate dependency: |%s| " % line)
                    dpkg = package(depline=line, top_flav = pkg.top_flav, top_quals = pkg.top_quals)

                    if not dpkg.namespace:
                        self.get_namespace(dpkg)

                    if not dpkg.prod:
                        continue

                    # get the hash for dependency
                    # -- it should have been converted already, so we pass lookup_only..
                    dhash = self.get_cached_hash(dpkg)

                    if not dhash:
                        # try unqualified...
                        logging.debug("retry without quals")
                        dpkg.top_quals=""
                        dhash = self.get_cached_hash(dpkg)

                    if not dhash:
                        logging.debug("skipping dependency %s -- no hash" % dpkg)
                        continue

                    spec["spec"][0][pkg.prod]["dependencies"][dpkg.prod] = {
                        "hash": dhash,
                        "type": ["build", "link"],
                        "namespace": dpkg.namespace,
                    }

            specl = []
            for line in dependlines:

                logging.debug("general dependency: |%s| " % line)

                dpkg = package(depline=line, top_flav = pkg.top_flav, top_quals=pkg.top_quals)

                #
                # again dependencies should have already been migrated, so this should just
                # lookup the hash for the dependency.
                #
                dhash = self.get_cached_hash(dpkg)

                if not dhash:
                    # try unqualified...
                    logging.debug("retry without quals")
                    dpkg.top_quals=""
                    dhash = self.get_cached_hash(dpkg)

                if not dhash:
                    logging.debug(
                        "skipping dependency %s -- no hash"
                        % repr((dpkg.prod, dpkg.ver, dpkg.flav, dpkg.quals))
                    )
                    continue

                tfl = pkg.spack_arch().split("-")

                if not dpkg.namespace:
                    self.get_namespace(dpkg)

                specl.append(
                    {
                        dpkg.prod: {
                            "version": dpkg.dotver,
                            "hash": dhash,
                            "parameters": {
                                "cppflags": [],
                                "cxxflags": [],
                                "ldflags": [],
                                "cflags": [],
                                "fflags": [],
                                "ldlibs": [],
                            },
                            "arch": {
                                "platform": tfl[0],
                                "platform_os": tfl[1],
                                "target": tfl[2],
                            },
                            "namespace": dpkg.namespace,
                            "compiler": {
                                "name": dpkg.spack_comp(0),
                                "version": dpkg.spack_comp(1),
                            },
                        }
                    }
                )

            specl.reverse()
            spec["spec"] = spec["spec"] + specl

        logging.debug("writing specfile %s" % specfile)
        sf = open(specfile, "w")
        sf.write(ruamel.yaml.dump(spec, default_style="1"))
        sf.close()

    def use_spack_for_hash(self, pkg):
        import spack.spec
 
        specfile = self.get_specfile(pkg)
        st = open(specfile, "r")
        sp = spack.spec.Spec.from_yaml(st)
        return sp.dag_hash()
        
    def reindex_for_hash_and_rename(self, pkg):
        #idir, thash = spack_reindex()
        thash = self.use_spack_for_hash(pkg)

        basedir = self.get_basedir(pkg)

        if thash:

            dest = self.get_basedir(pkg, thash)

            if os.path.exists(dest):
                logging.debug(
                    "removing duplicate for %s"
                    % repr(
                        [pkg.prod, pkg.ver, pkg.flav, pkg.quals, pkg.spack_arch(), thash]
                    )
                )
                os.system("rm -rf %s" % basedir)
            else:
                logging.debug("renaming to %s" % dest)
                os.rename(basedir, dest)
        else:
            logging.error("Error: unable to get hash for %s -- skipping" % pkg)
            os.system("rm -rf %s" % basedir)
          

        # now if we re-run spack_reindex, we shouldn't see any errors...

        #a,b =spack_reindex()
        #if b != "":
        #    raise AssertionError(
        #        "ack! spack reindex is failing when we don't expect it to \n%s %s" % (a,b)
        #    )
        return thash

    def unpack(self, s):
        """ unpack/parse a line from a ups table file """
        l1 = re.split("[(), ]+", s)
        logging.debug("unpack: list: %s" % repr(l1))
        if len(l1) > 2:
            return {"var": l1[1].strip(), "value": " ".join(l1[2:]).strip(), "args": " ".join(l1[1:]).strip(), "argl":l1[1:]}
        else:
            return {"var": "", "value": "", "args": ""}

    def unpack_execute(self, cmdstr):
        """ unpack/parse an execute statement from a ups table file """
        m1 = re.match('(.*)\("([^"]*)",([^,]*),?(.*)\)', cmdstr)
        m2 = re.match('(.*)\(([^,]*),([^,]*),?(.*)\)', cmdstr)
        if m1:
            return {"cmd": m1.group(2).strip('" '), "flags": m1.group(3).strip(), "envvar": m1.group(4).strip()}
        elif m2:
            return {"cmd": m2.group(2).strip('" '), "flags": m2.group(3).strip(), "envvar": m2.group(4).strip()}
        else:
            return {"cmd": "", "flags": "", "envvar": ""}

    def fix_ups_vars(self, tline, pkg):
        """ replace common ups table file variables """
        tline = (tline
            .replace("${UPS_PROD_DIR}", self.do_pdr(pkg.prod_dir))
            .replace("${UPS_UPS_DIR}", self.do_pdr(pkg.prod_dir) + "/ups")
            .replace("${UPS_PROD_VERSION}", pkg.ver)
            .replace("${UPS_SOURCE}", "source")
            .replace("${UPS_PROD_FLAVOR}", pkg.flav)
            .replace("${UPS_PROD_QUALIFIERS}", canon_quals(pkg.quals))
            .replace("${UPS_PROD_NAME_UC}", pkg.prod.upper()))
        return tline


    def fix_env_vars_python(self, val):
        # python doesn't interpolate, so actively replace it...
        if not val:
            return ""
        val = val.strip(' ')
        val = val.replace('"','\\"')
        val = '("%s")' % val
        if val.find("`") >= 0:
            val = re.sub("`([^`]*)`", '" + self.backquote("\\1") + "', val)
        if val.find("$") >= 0:
            val = re.sub("\\$\\{(\\w+)\\}","%(\\1)s",val)
            val = val + "% self.env_get(env)"
        return val

    def fix_env_vars_tcl(self, val):

        def fix_exec_tcl(m):
            what = re.sub("'([^']*)'","{\\1}",m.group(1))
            return "[exec %s]" % what

        # tcl does interpoplate, but needs $::env(name) not ${name}
        if not val:
            return ""
        val = val.strip(' ')
        val = val.replace('"','\\"')
        val = '"%s"' % val

        if val.find("`") >= 0:
            val = re.sub("`([^`]*)`", fix_exec_tcl, val)

        if val.find("$") >= 0:
            val = re.sub("\\$\\{(\\w+)\\}","$::env(\\1)",val)
            val = re.sub("\\$(\\w+)","$::env(\\1)",val)
        return val

    def fix_env_vars_lua(self, val):
        if not val:
            return ""
        # lua doesn't interpolate, so actively replace it...
        val = val.replace('"','\\"')
        val = '"%s"' % val
        if val.find("`") >= 0:
            val = 'string.gsub(%s, "`(.+)`", backquote)' % val
        if val.find("$") >= 0:
            val = 'string.gsub(string.gsub(%s, "%%${(%%w+)}", os.getenv),"%%$(%%w+)", os.getenv)' % val
        return val

    def clean_colon(self, s):
        s = s.replace(' :', '')
        s = s.replace(" ':'", '')

    @log_call
    def convert_table(self, pkg, thash):

        tclbase = os.environ["SPACK_ROOT"] + "/share/spack/modules"
        lmodbase = os.environ["SPACK_ROOT"] + "/share/spack/lmod"

        if not thash:
            raise AssertionError("must call convert_table with thash")

        shorthash = thash[:7]

        logging.debug("Handling: %s" % pkg)
        logging.info("Converting %s:" % pkg.table_file)

        logging.debug("thash: %s, shorthash %s" % (thash, shorthash))

        pkg.prodbits()
        pkg.topbits()

        tclmodulefile = "%s/%s/%s-%s-%s-%s" % (
            tclbase,
            pkg.spack_arch(),
            pkg.prod,
            pkg.dotver,
            pkg.spack_comp(),
            shorthash,
        )
        lmodmodulefile = "%s/%s/%s/%s/%s/%s-%s.lua" % (
            lmodbase,
            pkg.spack_arch(),
            pkg.spack_comp(0),
            pkg.spack_comp(1),
            pkg.prod,
            pkg.dotver,
            shorthash,
        )

        recipefile=  "%s/var/spack/repos/ups_to_spack/packages/%s/package.py" % (
            os.environ["SPACK_ROOT"],
            pkg.prod
        )

        # this actually appends to the recipe file

        recipe_out = outfile(recipefile,"a")
        recipe_out.enable()
        recipe_out.write(
            """

    # method to handle backquotes in actions
    def backquote(self, cmd):
        import os
        f = os.popen("cmd","r")
        res = f.read()
        f.close()
        return res

    # method to get modified environment so far
    def env_get(self, env):
        res = os.environ.copy()
        for name, actions env.group_by_name():
            for x in actions:
                x.execute(res)
        return res

"""
)
        recipe_out.disable()

        tcl_out = outfile(tclmodulefile)
        tcl_out.enable()
        tcl_out.write(
            """#%%Module1.0

    # $pkg.prod modulefile
    # generated by %s 

    set pkg.ver %s
    set prefix  %s
    """
            % (sys.argv[0], pkg.dotver, self.do_pdr(pkg.prod_dir))
        )
        tcl_out.disable()

        lmod_out = outfile(lmodmodulefile)
        lmod_out.enable()
        lmod_out.write(
            """-- -*- lua -*-
    -- Module file created by %s
    --

    whatis([[Name : %s]])
    whatis([[Version : %s]])

    function backquote(s)
       f=io.popen(s,"r"); 
       res=f:read("*all");
       f:close(); 
       return res;
    end

    """
            % (sys.argv[0], pkg.prod, pkg.dotver)
        )
        lmod_out.disable()

        flavor_ok = True
        in_action = False
 
        logging.debug("converting table file %s" % pkg.table_file)

        if pkg.table_file:
            tff = open(pkg.table_file, "r")
        else:
            tff = open("/dev/null", "r")

        for line in tff:

            logging.debug("processing table file line: %s" % line)
            line = line.strip()
            line = self.fix_ups_vars(line, pkg)

            # remove comments..
            line = re.sub("\#.*", "", line)

            if re.search("flavor\\s*=\\s*ANY", line, flags=re.IGNORECASE):
                flavor_ok = True
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.depth = recipe_out.depth - 2
                    in_action = False
                continue
            if re.search(
                "flavor\\s*=\\s*%s" % pkg.flav.replace("+", "\\+"),
                line,
                flags=re.IGNORECASE,
            ):
                flavor_ok = True
                continue
            if re.search("flavor\\s*=", line, flags=re.IGNORECASE):
                flavor_ok = False
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.write("\n\n")
                    in_action = False
                continue
            m = re.search(
                'qualifiers\\s*=\\s*"?([^" ]*)"?\\s*$', line, flags=re.IGNORECASE
            )
            if m and canon_quals(m.group(1)) == canon_quals(pkg.quals):
                logging.debug("qualifier match")
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.write("\n\n")
                    in_action = False
                if flavor_ok:
                    lmod_out.enable()
                    tcl_out.enable()
                    recipe_out.enable()
                else:
                    lmod_out.disable()
                    tcl_out.disable()
                    recipe_out.disable()
                continue
            if re.search("qualifiers\\s*=", line, flags=re.IGNORECASE):
                if m and m.group(1):
                    logging.debug("qualifier mismatch %s vs %s" % (canon_quals(m.group(1)),canon_quals(pkg.quals)))
                else:
                    logging.debug("qualifier mismatch")
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.write("\n\n")
                    in_action = False
                lmod_out.disable()
                tcl_out.disable()
                recipe_out.disable()
            if re.search("common:", line, flags=re.IGNORECASE):
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.write("\n\n")
                    in_action = False
                lmod_out.enable()
                tcl_out.enable()
                recipe_out.enable()
                continue
            if re.search("action\\s*=", line, flags=re.IGNORECASE):
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.write("\n\n")
                name = re.sub(".*action\\s*=\\s*", "", line, flags=re.IGNORECASE)
                tcl_out.write("\n  proc %s {} {\n" % name.lower())
                lmod_out.write("\n  function %s ()\n" % name.lower())
                recipe_out.write("\n    def tf_%s(self,env):\n" % name.lower())

                in_action = True
                continue
            if re.search("dodefaults\s*\(", line, flags=re.IGNORECASE):
                if in_action:
                    recipe_out.write("        env.set('%s_DIR' %s)\n" %(pkg.prod.upper(), self.do_pdr(pkg.prod_dir)))
                    recipe_out.write("        env.set('%s_FQ_DIR' %s)\n" %(pkg.prod.upper(), self.do_pdr(pkg.prod_dir)))
                    tcl_out.write(
                        "setenv %s_DIR %s\n" % (pkg.prod.upper(), self.do_pdr(pkg.prod_dir))
                    )
                    tcl_out.write(
                        "setenv %s_FQ_DIR %s\n" % (pkg.prod.upper(), self.do_pdr(pkg.prod_dir))
                    )
                    lmod_out.write(
                        'setenv("%s_DIR","%s");\n' % (pkg.prod.upper(), self.do_pdr(pkg.prod_dir))
                    )
                    lmod_out.write(
                        'setenv("%s_FQ_DIR","%s");\n' % (pkg.prod.upper(), self.do_pdr(pkg.prod_dir))
                    )
                continue

            if re.search("(env|path)Set\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    recipe_out.write("        env.set('%s',%s)\n" % (d["var"], self.fix_env_vars_python(d["value"])))
                    tcl_out.write("setenv %s %s\n" % (d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write('setenv("%s","%s");\n' % (d["var"], self.fix_env_vars_lua(d["value"])))
                continue

            if re.search("prodDir\s*\(", line, flags=re.IGNORECASE):
                if in_action:
                    d = self.unpack(line)

                    if d['var'] == "":
                        d['var'] = "_DIR"
                    if d['value'] == "":
                        d['value'] = self.do_pdr(pkg.prod_dir)

                    recipe_out.write("        env.set('%s%s',%s)\n" % (pkg.prod.upper(),d["var"], self.fix_env_vars_python(d["value"])))
                    tcl_out.write("setenv %s%s %s\n" % (pkg.prod.upper(),d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write('setenv("%s%s","%s");\n' % (pkg.prod.upper(), d["var"], self.fix_env_vars_lua(d["value"])))
                continue
                   
            if re.search("(env|path)unSet\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    recipe_out.write("        env.unset('%s')\n" % d["var"])
                    tcl_out.write("unsetenv %s\n" % (d["var"]))
                    lmod_out.write('unsetenv("%s");\n' % (d["var"]))
                continue
            if re.search("(env|path)prepend", line, flags=re.IGNORECASE):
                d = self.unpack(line)

                if d["value"].rfind(':') > len(d["value"])-3:
                   d["value"] = self.clean_colon(d["value"])

                if in_action:
                    recipe_out.write("        env.prepend_path('%s',%s)\n" % (d["var"], self.fix_env_vars_python(d["value"])))
                    tcl_out.write("prepend-path %s %s\n" % (d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write(
                        'prepend_path("%s",%s);\n' % (d["var"], self.fix_env_vars_lua(d["value"]))
                    )
                continue
            if re.search("(env|path)append", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    recipe_out.write("        env.append_path('%s',%s)\n" % (d["var"], self.fix_env_vars_python(d["value"])))
                    tcl_out.write("append-path %s %s\n" % (d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write(
                        'append_path("%s",%s);\n' % (d["var"], self.fix_env_vars_lua(d["value"]))
                    )
                continue
            if re.search("(env|path)remove\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    recipe_out.write("        env.remove_path('%s',%s)\n" % (d["var"], self.fix_env_vars_python(d["value"])))
                    tcl_out.write("remove-path %s %s\n" % (d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write(
                        'remove_path("%s",%s);\n' % (d["var"], self.fix_env_vars_lua(d["value"]))
                    )
                continue
            if re.search("addAlias\s*\(", line, flags=re.IGNORECASE):
                if in_action:
                    d = self.unpack(line)
                    recipe_out.write("        env.add_alias('%s',%s)\n" % (d["var"], self.fix_env_vars_python(d["value"])))
                    tcl_out.write("set-alias %s %s\n" % (d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write(
                        'set_alias("%s",%s);\n' % (d["var"], self.fix_env_vars_lua(d["value"]))
                    )
                continue

            if re.search("setup(required|optional)\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                cdep = self.convert_dependency(d["args"], pkg.top_flav, pkg.top_quals)
                if in_action and cdep:
                    tcl_out.write("module load %s \n" % cdep)
                    lmod_out.write('load("%s");\n' % cdep)
                continue

            if re.search("exeAction(Required|Optional)\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    recipe_out.write("        self.tf_%s(env)\n" % d["var"].lower())
                    tcl_out.write("%s\n" % d["var"].lower())
                    lmod_out.write("%s()\n" % d["var"].lower())
                

            if re.search("execute\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack_execute(line)
                if in_action:
                    if d["flags"] == "UPS_ENV":
                        recipe_out.write("        env.set('UPS_PROD_NAME','%s')\n" % pkg.prod)
                        tcl_out.write("setenv UPS_PROD_NAME %s\n" % pkg.prod)
                        tcl_out.write("setenv UPS_PROD_DIR %s\n" % self.do_pdr(pkg.prod_dir))
                        recipe_out.write("        env.set('UPS_UPS_DIR','%s')\n" %  self.do_pdr(pkg.prod_dir))
                        tcl_out.write("setenv UPS_UPS_DIR %s/ups\n" % self.do_pdr(pkg.prod_dir))
                        recipe_out.write("        env.set('VERSION','%s')\n" %  self.do_pdr(pkg.prod_dir))
                        tcl_out.write("setenv VERSION %s\n" % pkg.dotver)
                        recipe_out.write("        env.set('UPS_PROD_NAME','%s')\n" %  pkg.prod)
                        lmod_out.write('setenv("UPS_PROD_NAME","%s");\n' % pkg.prod)
                        recipe_out.write("        env.set('UPS_PROD_DIR','%s')\n" %  self.do_pdr(pkg.prod_dir))
                        lmod_out.write('setenv("UPS_PROD_DIR","%s");\n' % self.do_pdr(pkg.prod_dir))
                        recipe_out.write("        env.set('UPS_UPS_DIR','%s')\n" %  self.do_pdr(pkg.prod_dir))
                        lmod_out.write('setenv("UPS_UPS_DIR","%s/ups");\n' % self.do_pdr(pkg.prod_dir))
                        lmod_out.write('setenv("VERSION","%s");\n' % pkg.dotver)

                    if d["envvar"]:
                        recipe_out.write('        env.set(%s, self.backquote(%s))\n' % (d["envvar"], re.sub("'([^']*)'","{\\1}",self.fix_env_vars_python(d["cmd"]).strip('" '))))
                        tcl_out.write(
                            'setenv %s [exec %s]\n' % (d["envvar"], re.sub("'([^']*)'","{\\1}",self.fix_env_vars_tcl(d["cmd"]).strip('" ')))
                        )
                        lmod_out.write(
                            'setenv("%s",backquote(%s));\n' % ( d["envvar"], self.fix_env_vars_lua(d["cmd"]))
                        )
                    else:
                        recipe_out.write("        self.backquote(%s\n" % self.fix_env_vars_tcl(d["cmd"]))
                        tcl_out.write("exec %s\n" % self.fix_env_vars_tcl(d["cmd"]))
                        lmod_out.write('os.execute(%s);\n' % self.fix_env_vars_lua(d["cmd"]))
                    continue

            if re.search("end(if|unless)", line, flags=re.IGNORECASE):
                if in_action:
                    tcl_out.write("}\n\n")
                    lmod_out.write("end\n\n")
                    recipe_out.depth -= 2
                continue
            if re.search("\\belse\\b", line, flags=re.IGNORECASE):
                if in_action:
                    tcl_out.write("} else {\n")
                    lmod_out.write("else\n")
                    recipe_out.write("    else:\n")
                continue
            if re.search("\\bif\\s*\\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:

                    # fix evil test in assorted larsoft dependencies
                    m = re.match("sh -c 'for dd in ([a-z0-9]*);do \\[ -d (\\$.*)/",d["args"])
                    if m:
                       d["args"] = "test -d %s/%s" % (m.group(2), m.group(1))

                    tcl_out.write(
                        "if {![catch {exec %s} results options]} {\n" % self.fix_env_vars_tcl(d["args"]).strip('" ')
                    )
                    lmod_out.write('if (!os.execute(%s)) then\n' % self.fix_env_vars_lua(d["args"]))
                    recipe_out.write('        if not os.system(%s)):\n' % self.fix_env_vars_python(d["args"]))
                    recipe_out.depth += 2
                continue
            if re.search("\\bunless\\s*\\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    # fix evil test in assorted larsoft dependencies
                    m = re.match("sh -c 'for dd in ([a-z0-9]*);do \\[ -d (\\$.*)/",d["args"])
                    if m:
                       d["args"] = "test -d %s/%s" % (m.group(2), m.group(1))
                    
                    tcl_out.write(
                        "if {[catch {exec %s} results options]} {\n" % self.fix_env_vars_tcl(d["args"].strip('" '))
                    )
                    lmod_out.write('if (os.execute(%s)) then\n' % self.fix_env_vars_lua(d["args"]))
                    recipe_out.write('        if not not os.system(%s)):\n' % self.fix_env_vars_python(d["args"]))
                continue
            if re.search("\\bend\\b", line, flags=re.IGNORECASE):
                if in_action:
                    tcl_out.write("}\n")
                    lmod_out.write("end\n")
                    recipe_out.depth -= 2
                    in_action = False
                continue

        tcl_out.enable()
        lmod_out.enable()
        recipe_out.enable()

        if in_action:
            tcl_out.write("}\n")
            lmod_out.write("end\n")

        recipe_out.write("\n\n")
        recipe_out.write("    def setup_run_environment(self, env):\n")
        recipe_out.write("        self.tf_setup(env)\n")
        tcl_out.write("\nsetup\n")
        lmod_out.write("\nsetup();\n")

        tcl_out.close()
        lmod_out.close()
        recipe_out.close()

    def get_dep_vers(self, prod):

        for pkg in self.packages:
            if pkg.prod == prod:
                return pkg.ver
        return None

    def convert_dependency(self, setupargs, def_flav, def_qual):
        setupargs = setupargs.strip()
        lsa = setupargs.split(" ")
        prod = lsa[0]
        if len(lsa) == 1:
            logging.debug("lookup dep version...")
            ver = self.get_dep_vers(setupargs)
        else:
            logging.debug("version %s" % lsa[1])
            ver = lsa[1]
        if ver == None:
            # didn't find a version, dependency on nonexistent package...
            return None
        dpkg = package(prod=prod, ver=ver, flav=def_flav, quals=def_qual)
        dhash = self.get_cached_hash(dpkg)
        if dhash:
            return "%s-%s-%s-%s" % (dpkg.prod, dpkg.dotver, dpkg.spack_comp(), dhash[:7])
        else:
            # didn't find it in depend outputs...
            return None

    def parsed_ups_list(self, argv):
        ucmd = (
            "ups list -Kproduct:version:flavor:qualifiers:@prod_dir:@table_file "
            + " ".join(argv)
            + " 2>/dev/null"
        )
        res = []
        ulf = os.popen(ucmd, "r")
        for line in ulf:
            res.append(package(kline=line))
        ulf.close()
        return res

    def parsed_ups_dependencies(self, pkgl):
        res = []
        for pkg in pkgl:
            if pkg.flav == "NULL":
                flist = self.all_flavors
            else:
                flist = [ (pkg.flav, pkg.quals) ]
                
            for hf in flist:
                for line in pkg.dependlines(hosttype=hf[0]):
                    line.rstrip()
                    logging.debug("pud: line: %s" % line)
                    m = re.match("^[\|_ ]*", line)
                    depth = len(m.group(0)) / 3
                    p = package(
                        depline=line, top_flav=hf[0], top_quals=hf[1], depth=depth
                    )
                    logging.debug("pud: pkg: %s" % p)
                    res.append(p)

        res.sort(key=lambda x: "%2d:%s" % (99-x.depth,":".join((x.prod, x.ver, x.quals,x.top_flav,x.top_quals))))

        res = self.list_uniq(res)

        return res

    def list_uniq(self, res):
        ''' de-duplicate sorted list '''
        r2 = []
        len_r = len(res)
        for i in xrange(0,len_r-1):
            if res[i] != res[i+1]:
                r2.append(res[i])

        if len_r > 0:
            r2.append(res[len_r-1])

        return r2

    @log_call
    def migrate_all(self, argv):
        pkgl = self.parsed_ups_list(argv)
        self.packages = self.parsed_ups_dependencies(pkgl)
        logging.debug("migrate_all: packages: %s" % repr(self.packages))
        for pkg in self.packages:
            self.migrate_one(pkg)


if not os.environ.get("UPS_DIR", None) or not os.environ.get("SPACK_ROOT", None):
    print("This script requires UPS and Spack to both be setup.")
    print("Please source a UPS setups.sh and a Spack setup-env.sh before running.")
    sys.exit(1)


logging.basicConfig(level=logging.DEBUG)
pdr = None

#print("check: %s" %  sys.argv[1][:5])
if sys.argv[1][:6] == "--pdr=" :
    pdr = sys.argv[1][6:]
    #print("pdr=%s" % pdr)
    sys.argv = sys.argv[:1] + sys.argv[2:]

uts = ups_to_spack(pdr=pdr)

uts.migrate_all(sys.argv[1:])
