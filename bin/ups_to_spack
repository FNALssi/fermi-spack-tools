#!/usr/bin/env python

import os
import stat
import sys
import re
import os.path
import logging
import glob
import traceback
import select
import subprocess
import json

# we want to use the ruamel.yaml package from spack
sys.path.insert(1, "%s/lib/spack/external" % os.environ["SPACK_ROOT"])
sys.path.insert(1, "%s/lib/spack/external/py2" % os.environ["SPACK_ROOT"])
sys.path.insert(1, "%s/lib/spack" % os.environ["SPACK_ROOT"])
import ruamel.yaml as yaml
from spack.spec import Spec

PROOT=os.path.dirname(os.path.dirname(os.path.dirname(os.environ["SPACK_ROOT"])))

def log_call(f):
    """ decorator to log calls to functions at debug level """

    def logged(*args, **kwargs):
        logging.debug("entering %s%s%s" % (f.__name__, repr(args), repr(kwargs)))
        res = f(*args, **kwargs)
        logging.debug("leaving %s returning %s" % (f.__name__, repr(res)))
        return res

    return logged



_memory = {}
def remember(f):
    def wrap(*args, **kwargs):
        global _memory
        key = "%s_%s_%s" % (f.__name__,repr(args),repr(kwargs))
        if not key in _memory or not _memory[key]:
            logging.debug("remembering: %s" % f.__name__)
            _memory[key] = f(*args, **kwargs)
        return _memory[key]

    return wrap

def spack_reindex():
    """ 
        run spack reindex, 
        pick the hash value from the first 'No such file or directory' error
        and return it -- this is Really Important, because this is how
        this script discovers hash values for packages.
    """
    logging.debug("spack_reindex")
    f = os.popen("spack reindex 2>&1", "r")
    for line in f:
        if line.find("No such file or directory") > 0:
            logging.debug("saw error line: %s" % line)
            res = line.replace("'", "").strip()
            logging.debug("res now(1): %s" % res)
            m = re.match(".*?(/.*)-(.*)", res)
            f.close()
            if m:
                return m.group(1), m.group(2)

    f.close()
    return "", ""

known_cycle_deps = {}
depsmap = {}

def filter_cycles(deplines):
    global known_cycle_deps
    global depsmap
    res=[]
    d=['','','','','','','','','','','','','','','','','','','','','','','']
    for line in deplines:
        m = re.match("(^[|_ ]*)([^ ]*)", line)
        depth = len(m.group(1))/3
        name = m.group(2)
        d[depth] = name
        cycle = False
        for i in xrange(depth):
            if d[i+ 1] ==  known_cycle_deps.get(d[i],None):
                logging.debug("remembered cycle: (%s ->  %s) %s " % (d[i], d[i+1],  repr(d[:depth+1])))
                cycle=True

        for i in xrange(depth):
           if d[i] ==  name and not cycle:
                logging.debug("dropping cycle: " + repr(d[:depth+1]))
                cycle = True
                # so there are two candidates for the edge to drop to lose the cycle
                # the d[i-1]->d[i] and d[depth-1]->d[depth]
                # how do we pick?  well if we already have one then we shouldn't add
                # the other, and otherwise remember the later one because it
                # removes the least dependencies(?)
                if known_cycle_deps.get(d[depth-1],None) == d[depth]:
                    pass  # already known
                elif known_cycle_deps.get(d[i-1],None) == d[i]:
                    pass  # already known
                else:
                    # remember the later one?
                    known_cycle_deps[d[depth-1]] = d[depth]

        if not cycle:
            res.append(line)

    return res

@remember
def ups_depend(prod, ver, flav, qual, hosttype=''):
    """ run ups depend, return list of output lines """
    r1 = ups_x("depend -B", prod, ver, flav, qual, hosttype)
    if not r1:
        logging.debug("re-running.. without -B")
        r1 = ups_x("depend", prod, ver, flav, qual, hosttype)
    return filter_cycles(r1)

def canon_quals(qual):
    ll = qual.split(":")
    ll.sort()
    return ":".join(ll)

@remember
def ups_x(what, prod, ver, flav, qual, hosttype=''):
    """ run ups what, return list of output lines """

    # we've gotten some weird things from bugs upstream,
    # so try to capture where they come from...
    if qual:
        qual = qual.strip()
    if flav:
        flav = flav.strip()
    if qual == "-q":
        logging.error("Ouch! got a -q for qualifier!")
        traceback.print_stack()
        qual = ""

    if flav and flav[0] not in "NLD":
        logging.error("Ouch! got '%s' for flavor!")
        traceback.print_stack()
        flav = ""

    cmd = "ups %s %s %s %s %s %s %s %s %s 2>/dev/null" % (
        what,
        prod,
        ver,
        "-f" if flav else "",
        flav,
        "-q" if qual else "",
        qual,
        "-H" if hosttype else "",
        hosttype,
    )

    logging.debug("ups_x: cmd: %s" % cmd)
    p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE )

    # if we don't get a result in 30 seconds, fail...
    # example: dependency cycle with ups depend -B ...
    sr = select.select([p.stdout],[],[p.stdout],30)

    logging.debug("select returns: %s" % repr(sr))

    if not p.stdout in sr[0]:
        p.terminate()
        p.stdout.close()
        logging.error("Timeout on command: %s" % cmd)
        return []

    res = p.stdout.readlines()
    p.stdout.close()

    return res


class outfile:
    """ 
       class for a module output file -- tcl or lmod 
       like a regular file, but makes intervening directories, and
       has enable/disable for actually writing

    """

    def __init__(self, fname, flag="w"):
        self.generating = False
        self.saw_setup = False
        self.skip = False
        self.depth = 0
        self.fname = fname
        self.flag = flag
        if not os.access(os.path.dirname(fname), os.R_OK):
            os.makedirs(os.path.dirname(fname))
        if flag == "a":
            logging.debug("outfile.__init__: append for %s..." % fname)
            if not os.path.exists(fname):
                self.skip = True
                sreturn
            # this sort of breaks the wall, but we share the recipe
            # file for  multiple instances, so check if we've already
            # done this one...
            f = open(fname,"r")
            for line in f:
                if line.find("def setup_run_environment") > 0:
                    logging.debug("outfile.__init__: Already did table file for %s..." % fname)
                    self.skip = True
            f.close()
            if self.skip:
                return
        else:
            if os.path.exists(fname):
                self.skip = True
                return
        self.outf = open(fname, flag)
        logging.debug("outfile.__init__: opened: %s" % fname)
        self.setup_patterns = ["proc setup {} {","function setup ()","def tf_setup"]

    def enable(self):
        if self.skip:
            return 
        logging.debug("enabling: %s" % self.fname)
        self.generating = True

    def disable(self):
        logging.debug("disabling: %s" % self.fname)
        self.generating = False

    def raw_write(self, text):
        if self.skip:
            return 
        self.outf.write(text)

    def depth_check(self, text):
        pass

    def write(self, text):
        indenting = 0
        if self.generating:

            ldepth = self.depth_check(text)
            logging.debug("considiring writing %d %s" % (ldepth, text))

            if self.depth >= 0:
                # auto indent -- needed? mengel --definitely for python..
                text = ("    " * (ldepth) + text)

                logging.debug("writing on %d %s text: %s" % (ldepth, self.fname, text))
                self.outf.write(text)
            else:
                logging.debug("not writing on %d %s text: %s" % (ldepth, self.fname, text))
                # don't write what would send us under, but don't stick there..

    def close(self):
        #
        if self.skip:
            return
        #
        # make file not writable so module refresh will not stomp on it
        #
        if self.flag == "w":
            os.fchmod(self.outf.fileno(), (stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH))
        self.outf.close()
        self.depth = 0

class outfile_tcl(outfile):

    def depth_check(self, text):
        ldepth = self.depth
        before = self.depth
        self.depth -= text.count('}')
        self.depth += text.count('{')
        if self.depth != before:
             logging.debug("depth change: %s %s" % (before, self.depth))
        return ldepth

class outfile_lua(outfile):

    def depth_check(self, text):
        ldepth = self.depth
        before = self.depth
        l1 = re.split('\bend\b', text)
        self.depth -= len(l1)
        l1 = re.split('\b(function|then)\b', text)
        self.depth += len(l1)
        if self.depth != before:
             logging.debug("depth change: %s %s" % (before, self.depth))
        return ldepth

class outfile_python(outfile):

    def depth_check(self, text):
        before = self.depth
        ldepth = self.depth
        if text.find("def tf_setup(") >= 0:
            if self.depth != 1:
                logging.debug("indent wrong at tf_setup method, fixing..")
            else:
                logging.debug("indent ok at tf_setup")
            ldepth = 1
            self.depth = 1
        if text.find("else:") >= 0:
            self.depth -= 1
            ldepth -= 1
        if len(text) > 1 and text[-2] == ':':
            self.depth += 1
        if self.depth != before:
             logging.debug("depth change: %s %s" % (before, self.depth))
        return ldepth

    # in python, there is no end of block symbol
    # so they just have to tell us
    def end_block(self):
        if self.generating:
            self.depth -= 1

class package:
    def __init__(
        self,
        depline=None,
        kline=None,
        top_flav=None,
        top_quals=None,
        depth=0,
        prod=None,
        ver=None,
        flav=None,
        quals=None,
        prod_fq_dir = None
    ):
        self.top_flav = top_flav
        self.top_quals = top_quals
        self.depth = depth
        self.prod_fq_dir = prod_fq_dir
        self.namespace = None
        if depline:
            depline = depline.lstrip("|_ ").rstrip()
            ll = depline.split(" ")
            self.prod, self.ver, fflag, self.flav, qflag, self.quals = ll[:6]

            if qflag != "-q":
                if qflag == "-z" and len(ll) > 6 and ll[6] == "-q":
                    self.quals =  ll[7]
                else:
                    self.quals = ""

            self.prod_dir = None
            self.table_file = None

        elif kline:
            kline = kline.strip().replace('"', "")
            ll = kline.split(" ")
            self.prod, self.ver, self.flav, self.quals, self.prod_dir, self.table_file = ll[:7]
        else:
            self.prod = prod
            self.ver = ver
            self.flav = flav
            self.quals = quals
            self.prod_dir = None
            self.table_file = None

        if self.quals == "-q":
            logging.error("Ouch! got a -q for qualifier!")
            traceback.print_stack()
            self.quals = ""

        self.uprod = self.prod
        self.prod = self.dashfix(self.prod)

    def dashfix(self,s):
        
        if s == "tbb":
            return "intel-tbb"
        if s in ("gcc","clang"):
            return "%s-runtime" % s
        if s != None:
            return  s.lower().replace("_","-")

    def __str__(self):
        return "%s %s -f %s -q '%s' top: -f %s -q '%s' depth %s" % (
            self.uprod,
            self.ver,
            self.flav,
            self.quals,
            self.top_flav,
            self.top_quals,
            self.depth,
        )
    def keyval(self):
        return "%s %s -f %s -q '%s'" % (
            self.uprod,
            self.ver,
            self.flav,
            self.quals,
        )

    def __repr__(self):
        return "<Package %s>" % self.__str__()

    def default_flavor(self, f_os):
        if f_os[:3] == "Dar":
            return "Darwin64bit+16.7.0"
        if f_os[:3] == "Lin":
            return "Linux64bit+3.10-2.17"
        return "Linux64bit+3.10-2.17"

    @remember
    @log_call
    def spack_arch(self):

        self.topbits()

        l1 = re.split("[- +]+", self.top_flav)
        logging.debug("l1: %s" % repr(l1))
        f_os = l1[0]
        f_osrel = l1[1] if len(l1) > 1 else ""
        f_libc = l1[2] if len(l1) > 2 else ""
        f_dist = l1[3] if len(l1) > 3 else ""

        if f_os == "NULL":
            f_os = ""

        l2 = re.split("[- +]*", self.default_flavor(f_os))
        logging.debug("l2: %s" % repr(l2))
        f_os = f_os if f_os else l2[0]
        f_osrel = f_osrel if f_osrel else l2[1] if len(l2) > 1 else ""
        f_libc = f_libc if f_libc else l2[2] if len(l2) > 2 else ""
        f_dist = f_dist if f_dist else l2[3] if len(l2) > 3 else ""

        tf_1 = f_os.lower().replace("64bit", "")

        tf_2 = "%s-%s" % (f_osrel, f_libc)

        if f_os[:3] == "Dar":
            tf_2 = re.sub("^-.*", "yosemite", tf_2)
            tf_2 = re.sub("13[-.].*", "mavericks", tf_2)
            tf_2 = re.sub("14[-.].*", "yosemite", tf_2)
            tf_2 = re.sub("15[-.].*", "elcapitan", tf_2)
            tf_2 = re.sub("16[-.].*", "sierra", tf_2)
            tf_2 = re.sub("17[-.].*", "highsierra", tf_2)
            tf_2 = re.sub("18[-.].*", "mojave", tf_2)
            tf_2 = re.sub("^[0-9].*", "yosemite", tf_2)

        if f_os[:3] == "Lin":
            tf_2 = re.sub(".*-2.17", "scientific7", tf_2)
            tf_2 = re.sub(".*-2.12", "scientificfermi6", tf_2)
            tf_2 = re.sub(".*-2.6", "scientificfermi5", tf_2)
            tf_2 = re.sub("^[0-9].*", "scientificfermi5", tf_2)

        # excessive intel-centrism...
        if f_os.find("64bit") > 0:
            tf_3 = "x86_64_v2"
        else:
            tf_3 = "x86"

        logging.debug("spack_arch(%s) -> %s-%s-%s" % (self.flav, tf_1, tf_2, tf_3))
        return "%s-%s-%s" % (tf_1, tf_2, tf_3)

    @remember
    def upslistargs(self):
        return "%s %s -f %s -q '%s'" % (self.uprod, self.ver, self.flav, self.quals)

    @remember
    def dependlines(self, hosttype = None):
        if not hosttype:
            hosttype = self.top_flav
        dependlines = ups_depend(self.uprod, self.ver, self.flav, self.quals, hosttype=hosttype )

        #
        # kluge for ifhdc -q python2[67]... add a python dependency
        #
        if self.quals[:6] == "python":
            logging.debug("saw python* quals: %s" % self.quals)
            vers= "v%s_%s_2" % (self.quals[6], self.quals[7])
            pylines = ups_depend("python", vers, "", "", hosttype=hosttype)
            if pylines:
                dependlines.append("|__%s" % pylines[0])

        return dependlines

    # utilities to flesh out useful bits we might not have...

    def prodbits(self):
        if self.table_file == None:
            res = ups_x("list", "-K@prod_dir:@table_file", self.upslistargs(), "", "")
            logging.debug("prod_dir etc returns: %s" % repr(res))
            if res:
                ll = res[0].strip().replace('"', "").split(" ")
                logging.debug("prod_dir etc splt: %s" % repr(ll))
                self.prod_dir = ll[0]
                self.table_file = ll[1]
        if self.prod_fq_dir == None:
            cmd =". `ups setup %s`; echo ${%s_FQ_DIR:-${%sSYS:-${%s_BASE:-$%s_DIR}}} " % (
                 self.keyval(), self.uprod.upper(), self.uprod.upper(), 
                 self.uprod.upper(), self.uprod.upper())
            logging.debug("getting fq_dir from %s" % cmd)
            f = os.popen(cmd,"r")
            self.prod_fq_dir = f.read()
            f.close()
            self.prod_fq_dir = self.prod_fq_dir.strip().replace("\n","")
            logging.debug("got fq_dir %s" % self.prod_fq_dir)

    def topbits(self):
        if self.top_quals == None and self.top_flav == None:
            self.top_quals = self.quals
            self.top_flav = self.flav

        if self.top_flav == "NULL":
            raise AssertionError("Should not have a NULL top flavor!")

        if self.ver:
            self.dotver = (self.ver[1:] if self.ver[0] in "bv" else self.ver).replace("_", ".")

    def spack_comp(self, splitpart = -1):
        self.topbits()
        res = "gcc-4.8.5"
        if self.top_quals.find("c7") >= 0:
            res = "clang-7.0.0"
        if self.top_quals.find("c2") >= 0:
            res = "clang-5.0.1"
        if self.top_quals.find("e21") >= 0:
            res= "gcc-12.2.0"
        if self.top_quals.find("e20") >= 0:
            res= "gcc-9.3.0"
        if self.top_quals.find("e19") >= 0:
            res= "gcc-8.2.0"
        if self.top_quals.find("e18") >= 0:
            res= "gcc-7.3.0"
        if self.top_quals.find("e17") >= 0:
            res = "gcc-7.3.0"
        if self.top_quals.find("e15") >= 0:
            res = "gcc-6.4.0"
        if self.top_quals.find("e14") >= 0:
            res = "gcc-6.3.0"
        if self.top_quals.find("e10") >= 0:
            res = "gcc-4.9.3"
        if self.top_quals.find("e7") >= 0:
            res = "gcc-4.9.2"
        if self.top_quals.find("e6") >= 0:
            res = "gcc-4.9.1"
        if self.top_quals.find("e5") >= 0:
            res = "gcc-4.8.2"
        if self.top_quals.find("e4") >= 0:
            res = "gcc-4.8.1"
        if splitpart == -1:
            return res
        else:
            return res.split("-")[splitpart]

class ups_to_spack:
    def __init__(self, pdr=None):
        self.depcache = {}
        self.made_spec = set()
        self.made_spec_write = set()
        self.already_done = set()
        self.known_hashes = {}
        self.pkglist = None
        if pdr:
            ll = pdr.split("/")
            self.pdrn = int(ll[0])+1
            ll[0] = ''
            self.pdrl = ll
        else:
            self.pdrl = None
        self.all_flavors = (
            ("Linux64bit+2.6-2.12", ""),
            ("Linux64bit+3.10-2.17", ""),
        )
        self.cache_file = os.environ["SPACK_ROOT"] + "/var/ups_to_spack.cache"

    @log_call
    def get_cached_hash(self, pkg, allow_recurse = False):

        if pkg.keyval() in self.known_hashes:
            return self.known_hashes[pkg.keyval()]

        dhash = self.get_cached_hash_once(pkg)

        if not dhash:
            try:
                dhash = self.use_spack_for_hash(pkg)
            except:
                pass

        if not dhash and allow_recurse:
            # try to make it recursively...
            logging.debug("DANGER: Trying recursive make_spec call on %s" % pkg)
            dhash = self.migrate_one(pkg, recurseflag=True)

        return dhash

    @log_call
    def get_cached_hash_once(self, pkg):
        pkg.topbits()
        sp_arch = pkg.spack_arch()
        thash = None
        if os.access(self.cache_file, os.R_OK):
            cf = open(self.cache_file, "r")
            pattern = ":".join(
                [pkg.uprod, pkg.ver, pkg.flav, pkg.quals, sp_arch]
            )

            logging.debug("get_cached_hash: looking for: '%s'" % pattern)

            for line in cf:
                if line.find(pattern) == 0:
                    thash = line[(line.rfind(":") + 1) :]

                    thash = thash.strip()
                    break
            cf.close()
        return thash

    @log_call
    def add_cached_hash(self, pkg, thash):

        if pkg.top_flav in ("NULL", ""):
            raise AssertionError(
                "trying to add '%s' flavor product to cache" % pkg.top_flav
            )

        cf = open(self.cache_file, "a")
        cf.write(
            ":".join(
                [
                    pkg.uprod,
                    pkg.ver,
                    pkg.flav,
                    pkg.quals,
                    pkg.spack_arch(),
                    thash,
                ]
            )
            + "\n"
        )
        cf.close()

    @log_call
    def make_cmake_config(self, pkg, thash):
        # this is so various packages can be found with 
        # cmake find_package()...
        # this has to be called after make_spec because
        # make_spec populates self.depcache...

        # for some packages we rely on their existing cmake bits...
        if pkg.prod  in ('root', 'hep-hpc', 'boost', 'cetmodules'):
            return

        # check if there is one...
        #f = os.popen("find %s -name %sConfig.cmake -print 2>/dev/null" % (pkg.prod_fq_dir, pkg.prod))
        #l = f.readlines()
        #f.close()
        #logging.debug("checking for Config.cmake: got %s" % repr(l))
        #if len(l) >= 1:
        #    # already is one...
        #    logging.debug("returning due to existing Config.cmake")
        #    return

        basedir = self.get_basedir(pkg, thash)
        cfname = "%s/%sConfig.cmake" % (basedir,pkg.prod)
        cfName = "%s/%s%sConfig.cmake" % (basedir,pkg.prod[0].upper(), pkg.prod[1:])
        cfNAME = "%s/%sConfig.cmake" % (basedir,pkg.prod.upper())
        logging.debug("Writing: %s" % cfname )
        d = os.path.dirname(cfname)
        if not os.path.exists(d):
            os.makedirs(d)
        f = open(cfname, "w")
        try:
            os.link(cfname, cfName)
            os.link(cfname, cfNAME)
        except:
            pass
        f.write("""
####### written by ups_to_spack  #######

message("${CMAKE_CURRENT_LIST_FILE} starting:")

get_filename_component(PACKAGE_PREFIX_DIR "${CMAKE_CURRENT_LIST_DIR}/" 
ABSOLUTE)

macro(set_and_check _var _file)
  set(${_var} "${_file}")
  if(NOT EXISTS "${_file}")
    message(FATAL_ERROR "File or directory ${_file} referenced by variable ${_va
r} does not exist !")
  endif()
endmacro()

macro(check_required_components _NAME)
  foreach(comp ${${_NAME}_FIND_COMPONENTS})
    if(NOT ${_NAME}_${comp}_FOUND)
      if(${_NAME}_FIND_REQUIRED_${comp})
        set(${_NAME}_FOUND FALSE)
      endif()
    endif()
  endforeach()
endmacro()

function(check_ups_version)
   message("ignoring check_ups_version()")
   IF(DEFINED ARGV3)
       message("setting ${ARGV3} TRUE")
       set(${ARGV3} TRUE PARENT_SCOPE)
   endif()
   if(DEFINED ARGV4)
       message("setting ${ARGV4} TRUE")
       set(${ARGV4} TRUE PARENT_SCOPE)
   endif()
endfunction()

################################################################################
####

if (EXISTS "${PACKAGE_PREFIX_DIR}/include")
  set(%(prod)s_inc_dir "${PACKAGE_PREFIX_DIR}/include")
endif()
if (EXISTS "${PACKAGE_PREFIX_DIR}/lib")
  set(%(prod)s_lib_dir "${PACKAGE_PREFIX_DIR}/lib")
endif()
if (EXISTS "${PACKAGE_PREFIX_DIR}/bin")
  set(%(prod)s_bin_dir "${PACKAGE_PREFIX_DIR}/bin")
endif()
if (EXISTS "${PACKAGE_PREFIX_DIR}/Modules")
  set(%(prod)s_modules_dir "${PACKAGE_PREFIX_DIR}/Modules")
endif()
if (EXISTS "${PACKAGE_PREFIX_DIR}/test")
  set(%(prod)s_test_dir "${PACKAGE_PREFIX_DIR}/test")
endif()

# prevent repeated inclusion
include_guard(GLOBAL)
if (IS_DIRECTORY "${%(prod)s_modules_dir}")
  message("adding ${%(prod)s_modules_dir} to CMAKE_MODULE_PATH\n")
  list(APPEND CMAKE_MODULE_PATH "${%(prod)s_modules_dir}")
endif()

if (IS_DIRECTORY "${%(prod)s_inc_dir}")
  include_directories(${%(prod)s_inc_dir})
endif()

""" % { "prod": pkg.prod})
        f2 = os.popen("test -d '%s' && cd '%s' && find lib -name  '*.so' -print 2>/dev/null" % (pkg.prod_fq_dir, pkg.prod_fq_dir), "r")
        liblist = f2.readlines()
        f2.close()
        for lib in liblist:
            m = re.match("lib/lib(.*).(so|dyld)", lib)
            if m:
                lspec = m.group(1)
                lib = "%s/%s" % (basedir, lib.strip())
                f.write('set_and_check(%s "%s")\n' % (
                     lspec.upper(), lib))

        for d in self.depcache.get(pkg.keyval(),[]):
            # some package have differently spelled cmake parts...
            if d == "boost":
                d = "Boost"
            if d == "root":
                d = "ROOT"
            if d == "hep-hpc":
               d = "hep_hpc"
            f.write("find_package(%s REQUIRED)\n" % d)
        f.write('message("${CMAKE_CURRENT_LIST_FILE} ends:")\n')
        f.close()

    def quals_to_flags(self, pkg):
        rl = [] 
        quals = pkg.quals
        if 0 <=  quals.find("debug"):
            rl.append("-g")
        if 0 <= quals.find("opt"):
            rl.append("-O3")
        flags = " ".join(rl)

        flags = """ 'cxxflags="%s"' 'cflags="%s"' """ % (flags, flags)

        comp = pkg.spack_comp().replace('-','@')

        if comp:
            flags = "%s %% %s" % (flags, comp)

        return flags
        

    @log_call
    def install(self, pkg):

        immeddeps = self.parsed_ups_dependencies([pkg] ,immed=True)
        dlist = []
        myarch = pkg.spack_arch()
        for dpkg in immeddeps:
             if dpkg.spack_arch() == myarch:
                 dpkg.topbits()
                 dlist.append("^ %s@%s arch=%s" % (dpkg.prod, dpkg.dotver, dpkg.spack_arch()))

        flags = self.quals_to_flags(pkg)


        # install with specific dependencies.
        cmd = "spack install --reuse --no-checksum ups_to_spack.%s@%s arch=%s %s %s"  % (
                pkg.prod, pkg.dotver,  pkg.spack_arch(), flags, " ".join(dlist))

        logging.warning("running: %s" % cmd)
        os.system(cmd)
        f = os.popen("spack find --very-long %s@%s arch=%s" % (pkg.prod, pkg.dotver, pkg.spack_arch()), "r")
        ll = f.readlines()
        f.close()

        if len(ll) > 1:
            hash = ll[-1].split(" ")[0]
            return hash
        else:
            if pkg.backuprecipe:
                os.rename(pkg.backuprecipe+".bak", pkg.backuprecipe)
            raise SystemExit("Couldn't migrate %s %s -f %s" % (pkg.prod, pkg.ver, pkg.flav))
           
    @log_call
    def migrate_one(self, pkg, recurseflag = False ):

        if pkg.keyval() in self.already_done:
            logging.debug("migrate_one: already done (by us): %s" % pkg)
            logging.debug("already done: %s " % self.already_done)
            return self.use_spack_for_hash(pkg)

        self.already_done.add(pkg.keyval())

        # could have been done by a previous run...
        thash = self.get_cached_hash_once(pkg)
        logging.debug("get_cached_hash_one returns %s for %s" % (thash, pkg))

        if not thash:
            self.make_recipe(pkg)
            nhash = self.install(pkg)
            self.add_cached_hash(pkg, nhash)
            self.convert_table(pkg, nhash)
        else:
            nhash = thash
            logging.debug("already done (elsewhere): %s" % pkg)

        return nhash

    @remember
    def get_repo_list(self):
        repolist = {}
        f = os.popen("spack repo list", "r")
        first=True
        for line in f.readlines():
           
            if first:
               first=False
               continue
            v = line.strip().split(" ")
            repolist[v[-1]] = v[0]
        f.close()
        return repolist



    @log_call
    def get_namespace(self, pkg):

        #pkg.namespace = self.get_prod_namespace(pkg.prod)
        pkg.namespace = "ups_to_spack"
        logging.debug("pkg %s namespace %s " % (pkg.prod, pkg.namespace))

    @remember
    def get_prod_namespace(self, prod):

        repolist = self.get_repo_list()

        for repo in repolist:
            pf = "%s/packages/%s/package.py" % (repo, prod)
            logging.debug("checking for %s..",pf)
            if os.access(pf , os.R_OK):
                return repolist[repo]
        return None

    def get_pkgname(self, pkg):
        # package names are BiCapitalized so fife_utils -> FifeUtils
        
        pkgname = pkg.prod.capitalize()
        pkgname = re.sub("[_-]([a-z])", lambda m: m.group(1).capitalize(), pkgname)
        return pkgname

    @log_call
    def make_recipe(self, pkg):
        pkg.topbits()
        pkg.prodbits()
        builtin_recipedir = "%s/var/spack/repos/builtin/packages/%s" % (
            os.environ["SPACK_ROOT"],
            pkg.prod,
        )
        uts_recipedir = "%s/var/spack/repos/ups_to_spack/packages/%s" % (
            os.environ["SPACK_ROOT"],
            pkg.prod,
        )
        
        uts_repo = "%s/var/spack/repos/ups_to_spack" % os.environ["SPACK_ROOT"]
        uts_repo_yaml = "%s/repo.yaml" % uts_repo
       

        # check that we have a ups_to_spack repository...
        if not os.access(uts_repo_yaml, os.R_OK):
            os.system("spack repo create %s ups_to_spack" % uts_repo)
            os.system("spack repo add --scope=default %s" % uts_repo )

        self.get_namespace(pkg)
        # pick out path parts before/after version...
        if pkg.prod_fq_dir:
           pd = pkg.prod_fq_dir
        elif pkg.prod_dir:
           pd = pkg.prod_dir
        else:
           pd = ""

        if pd and pd.find(pkg.ver) > 0:
            prodarea, prodpath = pd.split(pkg.ver)
        else:
            prodarea = prodpath = ""

        # always make a recipe in ups_to_spack for this instance, even if
        # there already is one, we should use ours for setups in newer
        # Spack versions
        # if (not pkg.namespace):
        if (True):

            
            # there has to be a recipe for the package for spack to
            # look at it, so make one that's (just) good enough to pass
            #
            pkgname = self.get_pkgname(pkg)
            pkg.namespace = "ups_to_spack"

            if not os.access(uts_recipedir, os.R_OK):
                os.makedirs(uts_recipedir)
        
            #
            # just stomp on existing recipes...
            #
            pf = uts_recipedir + "/package.py"
            pkg.backuprecipe = None
            try:
                os.rename(pf, pf+".bak")
                pkg.backuprecipe = pf
            except:
                pass
            #if (os.path.exists(uts_recipedir + "/package.py")):
            #    logging.debug("found existing recipe file for %s " % pkg)
            #    return

            recipe_f = open(pf, "w")
            recipe_f.write("# fake recipe from ups_to_spack\n")
            recipe_f.write(
                "from spack import *\nimport os\n\nclass %s(Package):\n    pass\n"
                % pkgname
            )
            recipe_f.write("""

    def url_for_version(self, version):\n
        url = 'file:///tmp/empty.tar'
        return url


    def install(self, spec, prefix):
        v = "v"+str(spec.version.underscored)
        if os.path.isdir("%(prodarea)s{0}%(prodpath)s".format(v)):
            os.system("cd %(prodarea)s{0}%(prodpath)s && find . -print | cpio -dumpv {1}".format(v, prefix))
        else:
            # UPS packages can be empty, spack wants *something* there...
            os.system("echo Converted empty UPS package > {0}/README".format(prefix))
        
""" % {"prodarea":prodarea, "prodpath":prodpath})

            # we need some variants to make the concretizer happy, and in the case of boost,
            # quite a few
            vmap = {
                "boost": [ "atomic", "chrono", "date_time", "container", "context", "contract",
                    "coroutine", "exception", "fiber", "filesystem", "graph", "graph_parallel",
                    "iostreams", "json", "locale", "log", "math", "mpi", "nowide", "program_options",
                    "python", "random", "regex", "serialization", "signals", "stacktrace", "system",
                    "test", "thread", "timer", "type_erasure", "wave" ],
                "libxml2": ["python"],
                "python": [ "bz2", "ctypes", "dbm", "debug", "libxml2", "lzma", "nis", "optimizations",
                    "pic", "pyexpat", "pythoncmd", "readline", "shared", "sqlite3", "ssl", "tix",
                    "tkinter", "ucs4", "uuid", "zlib" ],
                "sqlite": ["column_metadata"],
            }

            if pkg.prod in vmap:
                for vari in vmap[pkg.prod]:
                    recipe_f.write("\n    variant(\"%s\",default=False)\n" % vari)
                      
            # include a cxxstd variant if we see a c7 or e19 qualifier...
            if re.search("[ce][0-9]", pkg.quals):
                recipe_f.write("\n    variant('cxxstd',default='17')\n\n")

            # script ones need to be extendable..
            if pkg.prod in ("python","ruby","perl"):
                recipe_f.write("\n    extendable = True\n")

            # recipe_f.close() -- no! do this later after adding dependencies
        else:
            recipe_f = None

        for line in pkg.dependlines():
            if re.match("^\\|__[a-zA-Z]", line):
                dpkg = package(depline=line, top_flav = pkg.top_flav, top_quals=pkg.top_quals)
                # if we're writing a recipe, add the dependency, to it
                if recipe_f and  known_cycle_deps.get(pkg.prod) != dpkg.prod:
                    recipe_f.write(
                        "    depends_on('%s', type=('build','run'))\n" % dpkg.prod
                    )

        if recipe_f:
            recipe_f.close()

    def do_pdr(self, path):
        if self.pdrl and path:
            dl = path.split("/")
            dl = self.pdrl + dl[self.pdrn:]
            dest = '/'.join(dl)
        else:
            dest = path
        return dest

    def get_spack_config(self, tag):
        """
           look up a line in the spack config 
        """
        sr = os.environ.get("SPACK_ROOT")
        for fn in [ "%s/etc/spack/config.yaml" % sr, "%s/etc/spack/defaults/config.yaml" % sr ]:
            try:
                f = open(fn, "r")
            except:
                continue

            for line in f.readlines():
                pos = line.find("%s:" % tag)
                if pos >= 0:
                    val = line[(pos + len(tag)+1):]
                    f.close()
                    return val.strip()
            f.close()
        return ""

    def get_basedir(self, pkg, thash = ""):

        # find our install path...
        install_tree = self.get_spack_config('install_tree').strip(' "')
        install_path_scheme = self.get_spack_config('install_path_scheme').strip(' "')
        if (install_tree == ''):
            install_tree = self.get_spack_config('root').strip(' "')
            install_path_scheme = self.get_spack_config('all').strip(' "')

        basedir_fmt = "%s/%s" % (install_tree, install_path_scheme)

        #convert to %(name)s ...

        basedir_fmt = basedir_fmt.replace("${","%(" ).replace("}", ")s" )
        basedir_fmt = re.sub("\$([a-z][a-z_]*)", "%(\\1)s" , basedir_fmt)

        logging.debug("basedir_fmt %s " % (basedir_fmt))

        basedir = (basedir_fmt % {
            "spack": os.environ["SPACK_ROOT"],
            "ARCHITECTURE": pkg.spack_arch(),
            "COMPILERNAME": pkg.spack_comp(0),
            "COMPILERVER": pkg.spack_comp(1),
            "PACKAGE": pkg.prod,
            "VERSION": pkg.dotver,
            "HASH": thash,
        })

        
        logging.debug("basedir is now %s " % (basedir))
        return basedir

    @log_call
    @remember
    def use_spack_for_hash(self, pkg):
        pkg.topbits()
        f = os.popen("spack find --long %s@%s %s" % 
                 (pkg.prod, pkg.dotver, pkg.spack_arch() ),
             "r")
        ll = f.readlines()
        f.close()
        if len(ll) > 0:
            return ll[1].split(" ")[0]
        else:
            return None
        
    def unpack(self, s):
        """ unpack/parse a line from a ups table file """
        l1 = re.split("[(), ]+", s)
        logging.debug("unpack: list: %s" % repr(l1))
        if len(l1) > 2:
            res = {"var": l1[1].strip(), "value": " ".join(l1[2:]).strip(), "args": " ".join(l1[1:]).strip(), "argl":l1[1:]}
            # quotes are optional on the value; just strip theem off if present
            if res["value"] and res["value"][0]=='"' and res["value"][-1] == '"':
               res["value"] = res["value"][1:-1]
            return res
        else:
            return {"var": "", "value": "", "args": ""}

    def unpack_execute(self, cmdstr):
        """ unpack/parse an execute statement from a ups table file """
        m1 = re.match('(.*)\("([^"]*)",([^,]*),?(.*)\)', cmdstr)
        m2 = re.match('(.*)\(([^,]*),([^,]*),?(.*)\)', cmdstr)
        if m1:
            return {"cmd": m1.group(2).strip('" '), "flags": m1.group(3).strip(), "envvar": m1.group(4).strip()}
        elif m2:
            return {"cmd": m2.group(2).strip('" '), "flags": m2.group(3).strip(), "envvar": m2.group(4).strip()}
        else:
            return {"cmd": "", "flags": "", "envvar": ""}

    def fix_ups_vars(self, tline, pkg):
        """ replace common ups table file variables """
        tline = (tline
            .replace("${UPS_PROD_DIR}", self.do_pdr(pkg.prod_dir))
            .replace("${UPS_UPS_DIR}", self.do_pdr(pkg.prod_dir) + "/ups")
            .replace("${UPS_PROD_VERSION}", pkg.ver)
            .replace("${UPS_SOURCE}", "source")
            .replace("${UPS_PROD_FLAVOR}", pkg.flav)
            .replace("${UPS_PROD_QUALIFIERS}", canon_quals(pkg.quals))
            .replace("${UPS_PROD_NAME_UC}", pkg.prod.upper().replace('-','_'))
            .replace("${UPS_THIS_DB}", PROOT))
        return tline


    def fix_env_vars_python(self, pkg, val):
        # python doesn't interpolate, so actively replace it...
        if not val:
            return "''"
        val = val.strip(' ')
        val = val.replace('"','\\"')
        val = val.replace('\\\\"','\\"')

        val = '("%s")' % val
        if val.find("`") >= 0:
            val = re.sub("`([^`]*)`", '" + self.backquote("\\1", env) + "', val)
        if val.find("$") >= 0:
            val = re.sub("\\$\\{(\\w+)\\}","%(\\1)s",val)
            val = val + "% self.env_get(env)"
        val = val.replace(pkg.dotver,'"+str(self.spec.version)+"')
        val = val.replace(pkg.ver,'v"+str(self.spec.version.underscored)+"')
        val = val.replace(pkg.prod,'"+self.spec.name+"')
        val = val.replace('+""+','+')
        val = val.replace('+""+','+')
        logging.debug("val %s pkg %s" % (val,pkg))
        return val

    def fix_env_vars_tcl(self, val):

        def fix_exec_tcl(m):
            return '[eval "exec /bin/sh -c {%s}"]' % m.group(1)

        # tcl does interpoplate, but needs $::env(name) not ${name}
        if not val:
            return '""'
        val = val.strip(' ')
        val = val.replace('"','\\"')
        val = '"%s"' % val

        if val.find("[") >= 0:
            # its tcl, so escape brackets, too
            val = val.replace("[","\\[")
            val = val.replace("]","\\]")

        if val.find("`") >= 0:
            val = re.sub("`([^`]*)`", fix_exec_tcl, val)

        if val.find("$") >= 0:
            val = re.sub("\\$\\{(\\w+)\\}","[getenv \\1]",val)
            val = re.sub("\\$(\\w+)","[getenv \\1]",val)

        return val

    def fix_env_vars_lua(self, val):
        if not val:
            return ""
        # lua doesn't interpolate, so actively replace it...
        val = val.replace('"','\\"')
        val = '"%s"' % val
        if val.find("`") >= 0:
            val = 'string.gsub(%s, "`(.+)`", backquote)' % val
        if val.find("$") >= 0:
            val = 'string.gsub(string.gsub(%s, "%%${(%%w+)}", os.getenv),"%%$(%%w+)", os.getenv)' % val
        return val

    def clean_colon(self, s):
        s = s.replace(' :', '')
        s = s.replace(" ':'", '')

    def update_tcl_module_index(self, tclbase, thash, tclmodulefile):

        tcl_module_index = "%s/module-index.yaml" % (
            tclbase
        )

        if not os.path.exists(os.path.dirname(tcl_module_index)):
            os.makedirs(os.path.dirname(tcl_module_index))

        if not os.path.exists(tcl_module_index):
            f = open(tcl_module_index, "w")  
            f.write("module_index:\n")
            f.close()

        # check if entry exists

        f =  open(tcl_module_index, "r")
        found = False
        for line in f:
            if line.strip(' :\n') == thash:
                found = True
                break
        f.close()

        if not found:
            f = open(tcl_module_index, "a")
            f.write("  %s:\n    path: %s\n    use_name: %s\n" % (thash, tclmodulefile, os.path.basename(tclmodulefile)))
            f.close()

    @log_call
    def convert_table(self, pkg, thash):
        global known_cycle_deps

        tclbase = os.environ["SPACK_ROOT"] + "/share/spack/modules"
        lmodbase = os.environ["SPACK_ROOT"] + "/share/spack/lmod"

        if not thash:
            raise AssertionError("must call convert_table with thash")

        shorthash = thash[:7]

        logging.debug("Handling: %s" % pkg)
        logging.info("Converting %s:" % pkg.table_file)

        logging.debug("thash: %s, shorthash %s" % (thash, shorthash))

        pkg.prodbits()
        pkg.topbits()

        tclmodulefile = "%s/%s/%s-%s-%s-%s" % (
            tclbase,
            pkg.spack_arch(),
            pkg.prod,
            pkg.dotver,
            pkg.spack_comp(),
            shorthash,
        )
        lmodmodulefile = "%s/%s/%s/%s/%s/%s-%s.lua" % (
            lmodbase,
            pkg.spack_arch(),
            pkg.spack_comp(0),
            pkg.spack_comp(1),
            pkg.prod,
            pkg.dotver,
            shorthash,
        )

        self.update_tcl_module_index(tclbase, thash, tclmodulefile)

        recipefile=  "%s/var/spack/repos/ups_to_spack/packages/%s/package.py" % (
            os.environ["SPACK_ROOT"],
            pkg.prod
        )

        # this actually appends to the recipe file

        recipe_out = outfile_python(recipefile,"a")
        recipe_out.depth = 1
        recipe_out.raw_write(
            """
    # method to handle backquotes in actions
    def backquote(self, cmd, env):
        import os
        self.env_update(env)
        f = os.popen(cmd,"r")
        res = f.read().strip("\\n")
        f.close()
        self.env_restore()
        return res

    def system(self, cmd, env):
        self.env_update(env)
        res = os.system(cmd)
        self.env_restore()
        return res

    # update our environment from env
    def env_update(self, env):
        self._env_save = os.environ.copy()
        os.environ.update(self.env_get(env))
        return True

    def env_restore(self):
        os.environ.clear()    
        os.environ.update(self._env_save)
        return True

    # method to get modified environment so far
    def env_get(self, env):
        from collections import defaultdict, OrderedDict
        res = defaultdict(str)
        modifications = env.group_by_name()
        res.update(os.environ)
        for x in env:
            x.execute(res)
        # de-dup any *PATH* variables
        for name in res:
            if name.find("PATH") >= 0:
                res[name] = ":".join(list(OrderedDict.fromkeys(res[name].split(":"))))
        return res
                
            """)
        # we're already in a class

        tcl_out = outfile_tcl(tclmodulefile)
        tcl_out.raw_write(
            """#%%Module1.0

    # $pkg.prod modulefile
    # generated by %s 

    set pkg.ver %s
    set prefix  %s

proc getenv { x } {
  if { [catch {set v $::env($x)}] } {
     set v ''
  }
  return $v
}

    """
            % (sys.argv[0], pkg.dotver, self.do_pdr(pkg.prod_dir))
        )

        lmod_out = outfile_lua(lmodmodulefile)
        lmod_out.raw_write(
            """-- -*- lua -*-
    -- Module file created by %s
    --

    whatis([[Name : %s]])
    whatis([[Version : %s]])

    function backquote(s)
       f=io.popen(s,"r"); 
       res=f:read("*all");
       f:close(); 
       return res;
    end

    """
            % (sys.argv[0], pkg.prod, pkg.dotver)
        )

        flavor_ok = True
        in_action = False
 
        logging.debug("converting table file %s" % pkg.table_file)

        if pkg.table_file:
            tff = open(pkg.table_file, "r")
        else:
            tff = open("/dev/null", "r")

        for line in tff:

            logging.debug("processing table file line: %s" % line)
            line = line.strip()

            # sqlite (and others) have stray semicolons after some
            # table file actions, which confuses things later
            if line[-2:] == ");":
                line = line[:-1]

            line = self.fix_ups_vars(line, pkg)

            # remove comments..
            line = re.sub("\#.*", "", line)

            # kluge alert -- we aren't clever enough for some things,
            # so skip them:
            # 1) TRACE has obnoxious alias definitions...
            if (pkg.prod == "trace" and 
                re.search("addAlias\s*\(", line, flags=re.IGNORECASE)):
                continue
            # end kluges

            if re.search("action\\s*=", line, flags=re.IGNORECASE):
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.write("\n\n")
                    recipe_out.end_block()
                name = re.sub(".*action\\s*=\\s*", "", line, flags=re.IGNORECASE)
                tcl_out.write("\n  proc %s {} {\n" % name.lower())
                lmod_out.write("\n  function %s ()\n" % name.lower())
                recipe_out.write("\n")
                recipe_out.write("def tf_%s(self,env):\n" % name.lower())
                recipe_out.write("pass\n")

                in_action = True
                continue

            if re.search("flavor\\s*=\\s*ANY", line, flags=re.IGNORECASE):
                flavor_ok = True
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.end_block()
                    in_action = False
                continue
            if re.search(
                "flavor\\s*=\\s*%s" % pkg.flav.replace("+", "\\+"),
                line,
                flags=re.IGNORECASE,
            ):
                flavor_ok = True
                continue
            if re.search("flavor\\s*=", line, flags=re.IGNORECASE):
                flavor_ok = False
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.write("\n\n")
                    in_action = False
                continue
            m = re.search(
                'qualifiers\\s*=\\s*"?([^" ]*)"?\\s*$', line, flags=re.IGNORECASE
            )
            if m and canon_quals(m.group(1)) == canon_quals(pkg.quals):
                logging.debug("qualifier match")
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.write("\n\n")
                    in_action = False
                if flavor_ok:
                    lmod_out.enable()
                    tcl_out.enable()
                    recipe_out.enable()
                else:
                    lmod_out.disable()
                    tcl_out.disable()
                    recipe_out.disable()
                continue
            if re.search("qualifiers\\s*=", line, flags=re.IGNORECASE):
                if m and m.group(1):
                    logging.debug("qualifier mismatch %s vs %s" % (canon_quals(m.group(1)),canon_quals(pkg.quals)))
                else:
                    logging.debug("qualifier mismatch")
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.write("\n\n")
                    in_action = False
                lmod_out.disable()
                tcl_out.disable()
                recipe_out.disable()
            if re.search("common:", line, flags=re.IGNORECASE):
                if in_action:
                    lmod_out.write("end\n\n")
                    tcl_out.write("}\n\n")
                    recipe_out.write("\n\n")
                    in_action = False
                lmod_out.enable()
                tcl_out.enable()
                recipe_out.enable()
                continue
            if re.search("dodefaults\s*\(", line, flags=re.IGNORECASE):
                if in_action:
                    recipe_out.write("env.set('%s_DIR', '%s'%%{'ver':'v'+self.version.underscored})\n" % (pkg.prod.upper().replace('-','_'), self.do_pdr(pkg.prod_dir).replace(pkg.ver,'%(ver)s')))
                    recipe_out.write("env.set('%s_FQ_DIR', '%s'%%{'ver':'v'+self.version.underscored})\n" % (pkg.prod.upper().replace('-','_'), self.do_pdr(pkg.prod_dir).replace(pkg.ver,'%(ver)s')))
                    # note that setenv in the tcl module recipes doesn't set
                    # the environment in tcl, it just generates the code
                    # to set it; since ups actions defer evaluating $var
                    # to the shell they use them inline, so we need to
                    # both set them in tcl and generate them...
                    tcl_out.write(
                        "setenv %s_DIR %s\n" % (pkg.prod.upper().replace('-','_'), self.do_pdr(pkg.prod_dir))
                    )
                    tcl_out.write(
                        "set  ::env(%s_DIR) %s\n" % (pkg.prod.upper().replace('-','_'), self.do_pdr(pkg.prod_dir))
                    )
                    tcl_out.write(
                        "set  ::env(%s_FQ_DIR) %s\n" % (pkg.prod.upper().replace('-','_'), self.do_pdr(pkg.prod_dir))
                    )
                    tcl_out.write(
                        "setenv %s_DIR %s\n" % (pkg.prod.upper().replace('-','_'), self.do_pdr(pkg.prod_dir))
                    )
                    tcl_out.write(
                        "setenv %s_FQ_DIR %s\n" % (pkg.prod.upper().replace('-','_'), self.do_pdr(pkg.prod_dir))
                    )
                    lmod_out.write(
                        'setenv("%s_DIR","%s");\n' % (pkg.prod.upper().replace('-','_'), self.do_pdr(pkg.prod_dir))
                    )
                    lmod_out.write(
                        'setenv("%s_FQ_DIR","%s");\n' % (pkg.prod.upper().replace('-','_'), self.do_pdr(pkg.prod_dir))
                    )
                continue

            if re.search("(env|path)Set\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    if d["var"] == "PATH":
                        # usually someone trying to use dropit, but in this
                        # case it hoses the path...
                        continue
                    recipe_out.write("env.set('%s',%s)\n" % (d["var"], self.fix_env_vars_python(pkg, d["value"])))
                    tcl_out.write("set ::env(%s) %s\n" % (d["var"], self.fix_env_vars_tcl(d["value"])))
                    tcl_out.write("setenv %s %s\n" % (d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write('setenv("%s","%s");\n' % (d["var"], self.fix_env_vars_lua(d["value"])))
                continue

            if re.search("prodDir\s*\(", line, flags=re.IGNORECASE):
                if in_action:
                    d = self.unpack(line)

                    if d['var'] == "":
                        d['var'] = "_DIR"
                    if d['value'] == "":
                        d['value'] = self.do_pdr(pkg.prod_dir)
                    else:
                        d['value'] = "%s/%s" % (self.do_pdr(pkg.prod_dir),d['value'])

                    recipe_out.write("env.set('%s%s',%s)\n" % (pkg.prod.upper().replace('-','_'),d["var"], self.fix_env_vars_python(pkg, d["value"])))
                    tcl_out.write("set ::env(%s%s) %s\n" % (pkg.prod.upper().replace('-','_'),d["var"], self.fix_env_vars_tcl(d["value"])))
                    tcl_out.write("setenv %s%s %s\n" % (pkg.prod.upper().replace('-','_'),d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write('setenv("%s%s","%s");\n' % (pkg.prod.upper().replace('-','_'), d["var"], self.fix_env_vars_lua(d["value"])))
                continue
            if re.search("source(Required|Optional)\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    tcl_out.write("puts \"source %s\"\n" % self.fix_env_vars_tcl(d["args"]).strip('"'))
                    lmod_out.write('execute("source %s");\n' % self.fix_env_vars_lua(d["args"]))
                    # XXX can we do this in a recipe action?
                   
            if re.search("(env|path)unSet\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    recipe_out.write("env.unset('%s')\n" % d["var"])
                    tcl_out.write("unsetenv %s\n" % (d["var"]))
                    lmod_out.write('unsetenv("%s");\n' % (d["var"]))
                continue
            if re.search("(env|path)prepend", line, flags=re.IGNORECASE):
                d = self.unpack(line)

                if d["value"].rfind(':') > len(d["value"])-3:
                   d["value"] = self.clean_colon(d["value"])
              
                if d["var"] == "CMAKE_PREFIX_PATH":
                    pdir = "ap"
                else:
                    pdir = "pre"

                if in_action:
                    recipe_out.write("env.%spend_path('%s', %s)\n" % (pdir, d["var"], self.fix_env_vars_python(pkg, d["value"])))
                    tcl_out.write("%spend-path %s %s\n" % (pdir, d["var"], self.fix_env_vars_tcl(d["argl"][1])))
                    lmod_out.write(
                        '%spend_path("%s",%s);\n' % (pdir, d["var"], self.fix_env_vars_lua(d["argl"][1]))
                    )
                continue
            if re.search("(env|path)append", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    recipe_out.write("env.append_path('%s',%s)\n" % (d["var"], self.fix_env_vars_python(pkg, d["value"])))
                    tcl_out.write("append-path %s %s\n" % (d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write(
                        'append_path("%s",%s);\n' % (d["var"], self.fix_env_vars_lua(d["value"]))
                    )
                continue
            if re.search("(env|path)remove\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    recipe_out.write("env.remove_path('%s',%s)\n" % (d["var"], self.fix_env_vars_python(pkg, d["value"])))
                    tcl_out.write("remove-path %s %s\n" % (d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write(
                        'remove_path("%s",%s);\n' % (d["var"], self.fix_env_vars_lua(d["value"]))
                    )
                continue
            if re.search("addAlias\s*\(", line, flags=re.IGNORECASE):
                if in_action:
                    d = self.unpack(line)
                    recipe_out.write("#env.add_alias('%s',%s)\n" % (d["var"], self.fix_env_vars_python(pkg, d["value"])))
                    tcl_out.write("set-alias %s %s\n" % (d["var"], self.fix_env_vars_tcl(d["value"])))
                    lmod_out.write(
                        'set_alias("%s",%s);\n' % (d["var"], self.fix_env_vars_lua(d["value"]))
                    )
                continue

            if re.search("setup(required|optional)\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)

                if (known_cycle_deps.get(pkg.prod) == d["args"][0]):
                    # ignore dependencies leading to cycles from earlier
                    continue

                cdep = self.convert_dependency(d["args"], pkg.top_flav, pkg.top_quals)
                if in_action and cdep:
                    # punting on dependencies for python; use spack load -r
                    tcl_out.write("module load %s \n" % cdep)
                    lmod_out.write('load("%s");\n' % cdep)
                continue

            if re.search("exeAction(Required|Optional)\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    recipe_out.write("self.tf_%s(env)\n" % d["var"].lower())
                    tcl_out.write("%s\n" % d["var"].lower())
                    lmod_out.write("%s()\n" % d["var"].lower())
                

            if re.search("execute\s*\(", line, flags=re.IGNORECASE):
                d = self.unpack_execute(line)
                if in_action:
                    if d["flags"] == "UPS_ENV":
                        recipe_out.write("env.set('UPS_PROD_NAME','%s')\n" % pkg.prod)
                        tcl_out.write("set ::env(UPS_PROD_NAME) %s\n" % pkg.prod)
                        tcl_out.write("set ::env(UPS_PROD_DIR) %s\n" % self.do_pdr(pkg.prod_dir))
                        tcl_out.write("setenv UPS_PROD_NAME %s\n" % pkg.prod)
                        tcl_out.write("setenv UPS_PROD_DIR %s\n" % self.do_pdr(pkg.prod_dir))
                        recipe_out.write("env.set('UPS_UPS_DIR','%s')\n" %  self.do_pdr(pkg.prod_dir))
                        tcl_out.write("set ::env(UPS_UPS_DIR) %s/ups\n" % self.do_pdr(pkg.prod_dir))
                        tcl_out.write("setenv UPS_UPS_DIR %s/ups\n" % self.do_pdr(pkg.prod_dir))
                        recipe_out.write("env.set('VERSION','%s')\n" %  self.do_pdr(pkg.prod_dir))
                        tcl_out.write("set ::env(VERSION) %s\n" % pkg.dotver)
                        tcl_out.write("setenv VERSION %s\n" % pkg.dotver)

                        recipe_out.write("env.set('UPS_PROD_NAME','%s')\n" %  pkg.prod)
                        lmod_out.write('setenv("UPS_PROD_NAME","%s");\n' % pkg.prod)
                        recipe_out.write("env.set('UPS_PROD_DIR','%s')\n" %  self.do_pdr(pkg.prod_dir))
                        lmod_out.write('setenv("UPS_PROD_DIR","%s");\n' % self.do_pdr(pkg.prod_dir))
                        recipe_out.write("env.set('UPS_UPS_DIR','%s')\n" %  self.do_pdr(pkg.prod_dir))
                        lmod_out.write('setenv("UPS_UPS_DIR","%s/ups");\n' % self.do_pdr(pkg.prod_dir))
                        lmod_out.write('setenv("VERSION","%s");\n' % pkg.dotver)

                    if d["envvar"]:
                        if d["envvar"] == "PATH":
                            continue
                        recipe_out.write('env.set("%s", self.backquote(%s, env))\n' % (d["envvar"], self.fix_env_vars_python(pkg, d["cmd"]).strip()))
                        tcl_out.write(
                            'set ::env(%s) [eval "exec /bin/sh -c {" %s "}"]\n' % (d["envvar"], self.fix_env_vars_tcl(d["cmd"]))
                        )
                        tcl_out.write(
                            'setenv %s $::env(%s)\n' % (d["envvar"],d["envvar"])
                        )
                        lmod_out.write(
                            'setenv("%s",backquote(%s));\n' % ( d["envvar"], self.fix_env_vars_lua(d["cmd"]))
                        )
                    else:
                        recipe_out.write("self.backquote(%s, env)\n" % self.fix_env_vars_python(pkg, d["cmd"]))
                        tcl_out.write('eval "exec /bin/sh -c {" %s "}"\n' % self.fix_env_vars_tcl(d["cmd"]))
                        lmod_out.write('os.execute(%s);\n' % self.fix_env_vars_lua(d["cmd"]))
                    continue

            if re.search("end(if|unless)", line, flags=re.IGNORECASE):
                if in_action:
                    tcl_out.write("}\n\n")
                    lmod_out.write("end\n\n")
                    recipe_out.end_block()
                continue
            if re.search("\\belse\\b", line, flags=re.IGNORECASE):
                if in_action:
                    tcl_out.write("} else {\n")
                    lmod_out.write("else\n")
                    recipe_out.write("else:\n")
                    recipe_out.write("pass\n")
                continue
            if re.search("\\bif\\s*\\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:

                    # fix evil test in assorted larsoft dependencies
                    m = re.match("sh -c 'for dd in ([a-z0-9]*);do \\[ -d (\\$.*)/",d["args"])
                    if m:
                       d["args"] = "test -d %s/%s" % (m.group(2), m.group(1))

                    tcl_out.write(
                         "if {![eval \"catch {exec /bin/sh -c {%s}} results options\"]} {\n" % d["args"].replace('[','\\[').replace(']','\\]').replace('"','\\"').replace('$','\\$')
                    )
                    lmod_out.write('if (!os.execute("%s")) then\n' % d["args"].replace('"','\\"'))
                    recipe_out.write('if not self.system("%s", env):\n' % d["args"].replace('"','\\"'))
                    recipe_out.write('pass\n')
                continue
            if re.search("\\bunless\\s*\\(", line, flags=re.IGNORECASE):
                d = self.unpack(line)
                if in_action:
                    # fix evil test in assorted larsoft dependencies
                    m = re.match("sh -c 'for dd in ([a-z0-9]*);do \\[ -d (\\$.*)/",d["args"])
                    if m:
                       d["args"] = "test -d %s/%s" % (m.group(2), m.group(1))
                    
                    tcl_out.write(
                        "if {[catch {exec %s} results options]} {\n" % self.fix_env_vars_tcl(d["args"].strip())
                    )
                    lmod_out.write('if (os.execute(%s)) then\n' % self.fix_env_vars_lua(d["args"]))
                    recipe_out.write('if self.system(%s)):\n' % self.fix_env_vars_python(pkg, d["args"]))
                continue
            if re.search("\\bend\\b", line, flags=re.IGNORECASE):
                if in_action:
                    tcl_out.write("\n}\n")
                    lmod_out.write("\nend\n")
                    recipe_out.end_block()
                    in_action = False
                continue

        tcl_out.enable()
        lmod_out.enable()
        recipe_out.enable()

        logging.debug("on the way out, in_action %s" % in_action)

        if in_action:
            tcl_out.write("\n}\n")
            lmod_out.write("\nend\n")
            in_action = False
            recipe_out.end_block()

        recipe_out.raw_write("\n\n")
        recipe_out.raw_write("    def setup_run_environment(self, env):\n")
        recipe_out.raw_write("        self.tf_setup(env)\n")
        recipe_out.raw_write("        env.prepend_path('CMAKE_PREFIX_PATH',self.prefix)\n")
        recipe_out.raw_write("\n\n")
        recipe_out.raw_write("    def setup_dependent_build_environment(self, env, dep):\n")
        recipe_out.raw_write("        self.tf_setup(env)\n")
        recipe_out.raw_write("        env.prepend_path('CMAKE_PREFIX_PATH',self.prefix)\n")
     
        tcl_out.raw_write("\nsetup\n")
        lmod_out.raw_write("\nsetup();\n")

        tff.close()
        tcl_out.close()
        lmod_out.close()
        recipe_out.close()

    def get_dep_vers(self, prod):

        for pkg in self.packages:
            if pkg.prod == pkg.dashfix(prod):
                return pkg.ver
        return None

    @log_call
    def convert_dependency(self, setupargs, def_flav, def_qual):
        setupargs = setupargs.strip()
        lsa = setupargs.split(" ")
        prod = lsa[0]
        if len(lsa) == 1:
            logging.debug("lookup dep version...")
            ver = self.get_dep_vers(setupargs)
        else:
            logging.debug("version %s" % lsa[1])
            ver = lsa[1]
        quals = ''
        if len(lsa) > 2:
            last = ""
            for k in lsa[2:]:
                if last == '-q':
                   quals = k
                last = k
                   
        if ver == None:
            # didn't find a version, dependency on nonexistent package...
            return None
        dpkg = package(prod=prod, ver=ver, flav=def_flav, quals=quals)
        dpkg.topbits()
        dhash = self.get_cached_hash_once(dpkg)
        if dhash:
            return "%s-%s-%s-%s" % (dpkg.prod, dpkg.dotver, dpkg.spack_comp(), dhash[:7])
        else:
            # didn't find it in depend outputs...
            return None

    def parsed_ups_list(self, argv):
        ucmd = (
            "ups list -Kproduct:version:flavor:qualifiers:@prod_dir:@table_file "
            + " ".join(argv)
            + " 2>/dev/null"
        )
        res = []
        ulf = os.popen(ucmd, "r")
        for line in ulf:
            res.append(package(kline=line))
        ulf.close()
        return res

    def parsed_ups_dependencies(self, pkgl, immed=False):
        res = []
        immedl = []
        for pkg in pkgl:
            if pkg.flav == "NULL":
                flist = self.all_flavors
            else:
                flist = [ (pkg.flav, pkg.quals) ]
                
            for hf in flist:
                for line in pkg.dependlines(hosttype=hf[0]):
                    line.rstrip()
                    logging.debug("pud: line: %s" % line)
                    m = re.match("^[\|_ ]*", line)
                    depth = len(m.group(0)) / 3
                    p = package(
                        depline=line, top_flav=hf[0], top_quals=hf[1], depth=depth
                    )
                    logging.debug("pud: pkg: %s" % p)
                    res.append(p)
                    if depth == 1:
                        immedl.append(p)

        
        res.reverse()
 
        # was trying this, which now seems excessive and wasn't working...
        #res.sort(key=lambda x: "%2d:%s" % (99-x.depth,":".join((x.prod, x.ver, x.quals,x.top_flav,x.top_quals))))
        #res = self.list_uniq(res)

        if immed:
            return immedl
        else:
            return res

    def list_uniq(self, res):
        ''' de-duplicate sorted list '''
        r2 = []
        len_r = len(res)
        for i in range(0,len_r-1):
            if res[i] != res[i+1]:
                r2.append(res[i])

        if len_r > 0:
            r2.append(res[len_r-1])

        return r2

    @log_call
    def migrate_all(self, argv):
        pkgl = self.parsed_ups_list(argv)
        self.packages = self.parsed_ups_dependencies(pkgl)
        logging.debug("migrate_all: packages: %s" % repr(self.packages))
        for pkg in self.packages:
            logging.debug("migrating: %s" % pkg)
            self.migrate_one(pkg)


if not os.environ.get("UPS_DIR", None) or not os.environ.get("SPACK_ROOT", None):
    print("This script requires UPS and Spack to both be setup.")
    print("Please source a UPS setups.sh and a Spack setup-env.sh before running.")
    sys.exit(1)

pdr = None

#
# not using argparse 'cause the argv mostly gets passed to ups
# just pick off any leading "--" options
#
while sys.argv[1][:2] == "--":
    if sys.argv[1][:6] == "--pdr=" :
        pdr = sys.argv[1][6:]
        #print("pdr=%s" % pdr)

    elif sys.argv[1] == "--debug":
        logging.basicConfig(level=logging.DEBUG)

    else:
        print("Unknown flag %s" % sys.argv[1])

    sys.argv = sys.argv[:1] + sys.argv[2:]

uts = ups_to_spack(pdr=pdr)

if not os.path.exists("/tmp/empty.tar"):
    pid = os.getpid()
    d = "/tmp/d{0}".format(pid)
    os.mkdir(d)
    os.system("cd {0} && tar cf /tmp/empty.tar .".format(d))
    os.rmdir(d)

uts.migrate_all(sys.argv[1:])
