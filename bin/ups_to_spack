#!/usr/bin/env python
import os
import sys
import re
import os.path
import logging
import glob
import traceback

# we want to use the ruamel.yaml package from spack
sys.path.insert(1, "%s/lib/spack/external" % os.environ["SPACK_ROOT"])
import ruamel.yaml

#
# This script is a bit unorthodox in its control flow
# Basically, we make $SPACK_ROOT/opt/.../.spack/spec.yaml
# files as a side-effect of generating the hash value
# for a given product,version,flavor, and qualifiers
# [ which actually:
#   * makes an entry without the hash value in the directory,
#   * asks spack to reindex, and
#   * uses the error message from that to get the hash value
# Also, we need to generate hashes for dependencies, which
# will make the database directories as we go
#
# This currently has the odd problem that we make the spec files
# for all the dependencies, but ony make module files for the
# packages specified on the command line...
#


class outfile:
    """ 
       class for a module output file -- tcl or lmod 
       like a regular file, but makes intervening directories, and
       has enable/disable for actually writing

    """

    def __init__(self, fname):
        self.generating = False
        if not os.access(os.path.dirname(fname), os.R_OK):
            os.makedirs(os.path.dirname(fname))
        self.outf = open(fname, "w")
        logging.debug("outfile.__init__: opened: %s" % fname)
        self.fname = fname

    def enable(self):
        logging.debug("enabling: %s" % self.fname)
        self.generating = True

    def disable(self):
        logging.debug("disabling: %s" % self.fname)
        self.generating = False

    def write(self, text):
        if self.generating:
            logging.debug("writing on %s text: %s" % (self.fname, text))
            self.outf.write(text)

    def close(self):
        self.outf.close()

def default_flavor(f_os):
    if f_os[:3] == "Dar":
        return "Darwin64bit+16.7.0"
    if f_os[:3] == "Lin":
        return "Linux64bit+3.10-2.17"
    return ups_flavor()

def theirflavor(upsflav):
    """ 
        convert a ups flavor to a spack architecture string 
        this is incomplete, but covers most of the cases we care about
        and needs updating when we add new build qualifiers for art/larsoft
        and new supported os-es (i.e. scientific linux 8....)
    """
    logging.debug("theirflavor(%s)" % upsflav)
    l1 = re.split("[- +]*", upsflav)
    logging.debug("l1: %s" % repr(l1))
    f_os = l1[0]
    f_osrel = l1[1] if len(l1) > 1 else ""
    f_libc = l1[2] if len(l1) > 2 else ""
    f_dist = l1[3] if len(l1) > 3 else ""

    if f_os == "NULL":
        f_os = ""

    l2 = re.split("[- +]*", default_flavor(f_os))
    logging.debug("l2: %s" % repr(l2))
    f_os = f_os if f_os else l2[0]
    f_osrel = f_osrel if f_osrel else l2[1] if len(l2) > 1 else ""
    f_libc = f_libc if f_libc else l2[2] if len(l2) > 2 else ""
    f_dist = f_dist if f_dist else l2[3] if len(l2) > 3 else ""

    tf_1 = f_os.lower().replace("64bit", "")

    tf_2 = "%s-%s" % (f_osrel, f_libc)

    if f_os[:3] == "Dar":
        tf_2 = re.sub("13[-.].*", "marericks", tf_2)
        tf_2 = re.sub("14[-.].*", "yosemite", tf_2)
        tf_2 = re.sub("15[-.].*", "elcapitan", tf_2)
        tf_2 = re.sub("16[-.].*", "sierra", tf_2)
        tf_2 = re.sub("17[-.].*", "highsierra", tf_2)
        tf_2 = re.sub("18[-.].*", "mojave", tf_2)
        tf_2 = re.sub("^[0-9].*", "yosemite", tf_2)

    if f_os[:3] == "Lin":
        tf_2 = re.sub(".*-2.17",  "scientific7", tf_2)
        tf_2 = re.sub(".*-2.12",  "scientific6", tf_2)
        tf_2 = re.sub(".*-2.6",   "scientific5", tf_2)
        tf_2 = re.sub("^[0-9].*", "scientific5", tf_2)

    if override_os:
        tf_2 = override_os

    # excessive intel-centrism...
    if f_os.find("64bit") > 0:
        tf_3 = "x86_64"
    else:
        tf_3 = "i386"

    logging.debug("theirflavor(%s) -> %s-%s-%s" % (upsflav, tf_1, tf_2, tf_3))
    return "%s-%s-%s" % (tf_1, tf_2, tf_3)


ups_flavor_cache=None
def ups_flavor():
    """ run ups flavor and return string output """
    global ups_flavor_cache
    if not ups_flavor_cache:
        ups_flavor_cache=ups_x("flavor", "", "", "", "")[0]
    return ups_flavor_cache

def ups_depend(prod, ver, flav, qual):
    """ run ups depend, return list of output lines """
    return ups_x("depend", prod, ver, flav, qual)


def ups_parent_a():
    """ run ups parent -a, return list of output lines """
    upcachename="/tmp/upcache%d" % os.getppid()
    if os.path.exists(upcachename):
        f = open(upcachename,"r")
        res= f.readlines()
        f.close()
        return res
    return ups_x("parent", "-a", "", "", "", teefile=upcachename)


def ups_x(what, prod, ver, flav, qual, teefile=None):
    """ run ups what, return list of output lines """

    # we've gotten some weird things from bugs upstream,
    # so try to capture where they come from...
    if qual:
        qual=qual.strip()
    if flav:
        flav=flav.strip()
    if qual == '-q':
        logging.error("Ouch! got a -q for qualifier!")
        traceback.print_stack()
        qual = ''

    if flav and flav[0] not in "NLD":
        logging.error("Ouch! got '%s' for flavor!")
        traceback.print_stack()
        flav = ''

    if teefile:
       teebits = " | tee %s" % teefile
    else:
       teebits = ""
        
    cmd = "ups %s %s %s %s %s %s %s 2>/dev/null %s" % (
        what,
        prod,
        ver,
        "-f" if flav else "",
        flav,
        "-q" if qual else "",
        qual,
        teebits
    )
    logging.debug("ups_x: cmd: %s" % cmd)
    f = os.popen(cmd, "r")
    res = f.readlines()
    f.close()
    return res


def guess_compiler(flavor, quals):
    """ guess what compiler was used based on qualifiers and flavor """
    if quals.find("c2") > 0:
        return "clang-5.0.1"
    if quals.find("e17") > 0:
        return "gcc-7.3.0"
    if quals.find("e15") > 0:
        return "gcc-6.4.0"
    if quals.find("e14") > 0:
        return "gcc-6.3.0"
    if quals.find("e10") > 0:
        return "gcc-4.9.3"
    if quals.find("e7") > 0:
        return "gcc-4.9.2"
    if quals.find("e6") > 0:
        return "gcc-4.9.1"
    if quals.find("e5") > 0:
        return "gcc-4.8.2"
    if quals.find("e4") > 0:
        return "gcc-4.8.1"
    if flavor.find("2.17") > 0:
        return "gcc-4.8.5"
    if flavor.find("2.12") > 0:
        return "gcc-4.4.7"
    return "gcc-4.1.1"  # sl5 compiler by default


def spack_reindex():
    """ 
        run spack reindex, 
        pick the hash value from the first 'No such file or directory' error
        and return it -- this is Really Important, because this is how
        this script discovers hash values for packages.
    """
    logging.debug("spack_reindex")
    f = os.popen("spack reindex 2>&1", "r")
    for line in f:
        if line.find("No such file or directory") > 0:
            logging.debug("saw error line: %s" % line)
            res = line.replace("'", "").strip()
            logging.debug("res now(1): %s" % res)
            m = re.match(".*?(/.*)-(.*)", res)
            f.close()
            if m:
                return m.group(1), m.group(2)
     
    f.close()
    return "",""


def ups_prod_dir(prod, ver, flav, qual):
    res = ups_x("list -K@prod_dir", prod, ver, flav, qual)
    print("ups_prod_dir: got: %s" % repr(res))
    if res:
        return res[0].strip().strip('"')
    else:
        return ""


def make_spec(prod, ver, dotver, flav, qual, theirflav, orig_flav=None, orig_qual=None):
    """ 
       make the .spack/spec.yaml file and possibly a minimal recipe for 
       a given ups product.  This involves going through the ups dependencies
       of the package, adding the direct dependencies to the spec and 
       recipe, and adding all the dependencies to the spec.yaml file
       We use get_hash, above, to find the hash 
       We're using the yaml library from spack to write the .yaml file
       from a dictionary
    """
    if qual == '-q':
        logging.error("Ouch! got a -q for qualifier!")
        traceback.print_stack()
        qual = ''

    recipedir = "%s/var/spack/repos/builtin/packages/%s" % (
        os.environ["SPACK_ROOT"],
        prod,
    )
    basedir = "%s/opt/spack/%s/%s-%s/%s-%s" % (
        os.environ["SPACK_ROOT"],
        theirflav,
        compiler,
        compver,
        prod,
        dotver,
    )

    specfile = "%s/.spack/spec.yaml" % basedir

    if not os.access(os.path.dirname(specfile), os.R_OK):
        os.makedirs(os.path.dirname(specfile))

    if not os.access(recipedir, os.R_OK):
        os.makedirs(recipedir)

    logging.debug("making symlinks in basedir %s" % basedir)
    # link in bin/ lib/ etc. dirs from ups directory so links paths might work
    ups_dir = ups_prod_dir(prod, ver, flav, qual)

    if ups_dir:
        for d in glob.glob("%s/*" % ups_dir):
            if os.path.isdir(d):
                try:
                    os.symlink(d, "%s/%s" % (basedir, os.path.basename(d)))
                except:
                    pass

    if not os.access(recipedir + "/package.py", os.R_OK):
        # there has to be a recipe for the package for spack to
        # look at it, so make one that's (just) good enough to pass
        recipe_f = open(recipedir + "/package.py", "w")
        recipe_f.write(
            "from spack import *\n\nclass %s(AutotoolsPackage):\n    pass\n"
            % prod.capitalize()
        )
        # recipe_f.close() -- no! do this later after adding dependencies
    else:
        recipe_f = None

    tfl = theirflav.split("-")

    # create base spec file structure for the .yaml file writer
    spec = {
        "spec": [
            {
                prod: {
                    "version": dotver,
                    "arch": {
                        "platform": tfl[0],
                        "platform_os": tfl[1],
                        "target": tfl[2],
                    },
                    "compiler": {"version": compver, "name": compiler},
                    "namespace": "builtin",
                    "parameters": {
                        "cppflags": [],
                        "cxxflags": [],
                        "ldflags": [],
                        "cflags": [],
                        "fflags": [],
                        "ldlibs": [],
                    },
                }
            }
        ]
    }

    if not orig_flav:
        orig_flav = flav

    if not orig_qual:
        orig_flav = qual 

    dependlines = ups_depend(prod, ver, orig_flav, orig_qual)

    if len(dependlines) > 1:
        # only add a dependencies section if there are any dependencies
        spec["spec"][0][prod]["dependencies"] = {}

        dependlines = dependlines[1:]
        dependlines.reverse()

        for line in dependlines:
            if re.match("^\\|__[a-z]", line):
                # it is an immediate dependency
                line = line.lstrip("|_ ")
                logging.debug("immediate dependency: |%s| " % line)
                ll = line.split(" ")
                dprod, dver, fflag, dflav, qflag, dquals = ll[:6]
                if qflag != "-q":
                    dquals = ""

                if not dprod:
                    continue

                # get the hash for dependency
                # -- it should have been converted already, so we pass lookup_only..

                dhash = get_hash(dprod, dver, dflav, dquals, compiler, compver, orig_flav, orig_qual, lookup_only=True)

                spec["spec"][0][prod]["dependencies"][dprod] = {
                    "hash": dhash,
                    "type": ["build", "link"],
                }

                # if we're writing a recipe, add the dependency, to it
                if recipe_f:
                    recipe_f.write(
                        "    depends_on('%s', type=('build','run'))\n" % dprod
                    )

        if recipe_f:
            # okay, *now* we can close the recipe file
            recipe_f.close()

        specl = []
        for line in dependlines:

            # ups depend puts ascii art tree stuff on the front..
            line = line.lstrip("|_ ")

            ll = line.split(" ")
            dprod, dver, fflag, dflav, qflag, dquals = ll[:6]

            if qflag != "-q":
                dquals = ""

            #
            # again dependencies should have already been migrated, so this should just
            # lookup the hash for the dependency.
            #
            dhash = get_hash(dprod, dver, dflav, dquals, compiler, compver, orig_flav, orig_qual, lookup_only = True)
            ddotver = dver.replace("v", "").replace("b", "").replace("_", ".")

            tfl = theirflav.split("-")

            specl.append(
                {
                    dprod: {
                        "version": ddotver,
                        "hash": dhash,
                        "parameters": {
                            "cppflags": [],
                            "cxxflags": [],
                            "ldflags": [],
                            "cflags": [],
                            "fflags": [],
                            "ldlibs": [],
                        },
                        "arch": {
                            "platform": tfl[0],
                            "platform_os": tfl[1],
                            "target": tfl[2],
                        },
                        "namespace": "builtin",
                        "compiler": {"name": compiler, "version": compver},
                    }
                }
            )

        specl.reverse()
        spec["spec"] = spec["spec"] + specl

    logging.debug("writing specfile %s" % specfile)
    sf = open(specfile, "w")
    sf.write(ruamel.yaml.dump(spec, default_style="1"))
    sf.close()

 
    idir, thash = spack_reindex()

    if thash:
        if basedir != idir:
            logging.debug("spack thinks it should be directory %s not %s"% (idir, basedir))
        dest = "%s-%s" % (basedir, thash)
        cf = open(cache_file, "a")
        cf.write(":".join([prod, ver, flav, qual, theirflav, thash]) + "\n")
        if os.path.exists(dest):
            logging.debug("removing duplicate for %s"% repr([prod, ver, flav, qual, theirflav, thash]))
            os.system("rm -rf %s" % basedir)
        else:
            logging.debug("renaming to %s" % dest)
            os.rename(basedir, dest)
    else:
        logging.error("Error: unable to get hash for %s" % repr([prod, ver, flav, qual ]))
        os.system("rm -rf %s" % basedir)

    # now if we re-run spack_reindex, we shouldn't see any errors...
    if spack_reindex()[1] != "":
        raise Exception("ack! spack reindex is failing when we don't expect it to")

    return thash

ghdepth = 0
ghrevis = set()

def get_hash(dprod, dver, dflav, dquals, compiler, compver, short=False, orig_flav=None, orig_qual=None, lookup_only=True):

    key = "get_hash(%s, %s, %s, %s, %s, %s)" % (
        dprod,
        dver,
        dflav,
        dquals,
        compiler,
        compver,
    )

    global ghrevis

    if key in ghrevis:
        logging.error("Ouch! avoiding cycle on %s" % key)
        return

    ghrevis.add(key)

    global ghdepth
    ghdepth = ghdepth + 1
    if ghdepth > 40:
        raise AssertionError("recursing excessively")

    logging.debug("[%s] %s"%(ghdepth, key))

    theirflav = theirflavor(dflav)
    thash = None

    # check the cache file to see if we have it already
    # use the parents qualifiers if available
    if not orig_flav:
        orig_flav = dflav
    if not orig_qual:
        orig_qual = dquals

    if os.access(cache_file, os.R_OK):
        cf = open(cache_file, "r")
        if short:
            pattern = ":".join([dprod, dver, dflav[:4]])
        else:
            pattern = ":".join([dprod, dver, dflav, dquals, theirflav])

        thash = None
        for line in cf:
            if line.find(pattern) == 0:
                thash = line[(line.rfind(":") + 1) :]

                thash = thash.strip()
                break
        cf.close()

    if lookup_only:
        return thash

    # if not, call make_spec to make the spec and get the hash, and convert
    # the table file
    ddotver = dver.replace("v", "").replace("b", "").replace("_", ".")

    if not thash:
        thash = make_spec(dprod, dver, ddotver, dflav, dquals, theirflav, orig_flav, orig_qual)
        f = os.popen(
            "ups list -Kproduct:version:flavor:qualifiers:@prod_dir:@table_file %s %s -f %s -q '%s' 2>/dev/null"
            % (dprod, dver, dflav, dquals),
            "r",
        )
        ulline = f.read()
        f.close
        convert_tablefile_from_line(ulline,thash)

    ghdepth = ghdepth - 1
    ghrevis.remove(key)

    return thash


def unpack(s):
    """ unpack/parse a line from a ups table file """
    l1 = re.split("[(), ]+", s)
    logging.debug("unpack: list: %s" % repr(l1))
    if len(l1) > 2:
        return {"var": l1[1], "value": " ".join(l1[2:]), "args": " ".join(l1[1:])}
    else:
        return {"var": "", "value": "", "args": ""}


def unpack_execute(cmdstr):
    """ unpack/parse an execute statement from a ups table file """
    m = re.match("(.*)\(([^,]*),([^,]*),?(.*)\)", cmdstr)
    if m:
        return {"cmd": m.group(1), "flags": m.group(3), "envvar": m.group(2)}
    else:
        return {"cmd": "", "flags": "", "envvar": ""}


def fix_ups_vars(tline, prod_dir, version):
    """ replace common ups table file variables """
    return (
        tline.replace("${UPS_PROD_DIR}", prod_dir)
        .replace("${UPS_UPS_DIR}", prod_dir + "/ups")
        .replace("${UPS_PROD_VERSION}", version)
        .replace("${UPS_SOURCE}", "source")
        .replace("$", "\\$")
    )


def convert_dependency(setupargs):
    # XXX fix me -- need to make the module file name not the plain package name
    return setupargs


compiler = None
compver = None
compdashver = None

ups_parent_cache = None
all_flavors = set()
all_their_flavors = set()


def load_ups_parent_cache():
    global ups_parent_cache
    global all_flavors
    if ups_parent_cache:
        return
    logging.debug("starting: load_ups_parent_cache")
    curkey = None
    ups_parent_cache = {}
    for line in ups_parent_a():
        line = line.rstrip()
        line = re.sub(" -z [^ ]+", "", line)
        line = re.sub("\[via.*\]+", "", line)

        if not line:
            continue
        if not line.find("-q") > 0:
            line = line + " -q "

        sline = line.lstrip("|_ ")

        ll = sline.split(" ")
        tf = theirflavor(ll[3])

        # only add it if it comes out to one we don't have already
        # -- but this would need flavor and compiler ... nevermind
        #if tf not in all_their_flavors:
        #    all_their_flavors.add(tf)

        if ll[5] == "-q":
            all_flavors.add((ll[3], ""))
        else:
            all_flavors.add((ll[3], ll[5]))

        if not line[0] in " |_":
            curkey = line
            if not curkey in ups_parent_cache:
                ups_parent_cache[curkey] = []
        elif curkey:
            ups_parent_cache[curkey].append(line)

    logging.debug("got all_flavors of %s" % repr(all_flavors))
    logging.debug("leaving: load_ups_parent_cache")

    # l = ups_parent_cache.keys()
    # l.sort()
    # print("\n".join(l))


def needed_flavor_quals(product, version, flavor, quals):
    global all_flavors
    res = set()

    load_ups_parent_cache()

    logging.debug(
        "entering needed_flavor_quals %s %s %s %s" % (product, version, flavor, quals)
    )
    for line in ups_parent_cache[
        "%s %s -f %s -q %s" % (product, version, flavor, quals)
    ]:
        logging.debug("checking line: %s" % line)
        line = line.lstrip("|_ ")
        ll = line.split(" ")
        res.add((ll[3], ll[5]))

    if flavor == "NULL" and not res:
        for f, q in all_flavors:
            res.add((f, q))

    if not res:
        res.add((flavor, quals))

    logging.debug("needed_flavor_quals: returning: %s" % repr(res))

    return res


def convert_tablefile_from_line(line,thash=None):
    global override_os, cache_file  # hint this should all be a class...
    global compdashver, compiler, compver

    logging.debug("convert_tablefile_from_line: line: %s" % line)

    line.strip()
    if not line:
        return
    l1 = line.replace('"', "").split(" ")
    logging.debug("split: %s" % repr(l1))
    product, version, oflavor, oquals, prod_dir, table_file = l1[:6]

    convert_tablefile(product, version, oflavor, oquals, prod_dir, table_file, oflavor, oquals, thash=thash)
    l_needed = needed_flavor_quals(product, version, oflavor, oquals)
    for nflavor, nquals in l_needed:
        if not( nflavor == oflavor and nquals == oquals):
            convert_tablefile(product, version, nflavor, nquals, prod_dir, table_file, oflavor, oquals)

convert_tablefile_visited = set()

def convert_tablefile(product, version, flavor, quals, prod_dir, table_file, orig_flav=None, orig_qual=None, thash=None):

    logging.debug("entering convert_tablefile(%s)" % repr((product, version, flavor, quals, prod_dir, table_file, orig_flav, orig_qual, thash)))

    global convert_tablefile_visited
    if (product, version, flavor, quals, prod_dir) in convert_tablefile_visited:
        logging.debug("cycle prevention exit")
        return
    convert_tablefile_visited.add((product, version, flavor, quals, prod_dir))

    global compdashver, compiler, compver
    tclbase = os.environ["SPACK_ROOT"] + "/share/spack/modules"
    lmodbase = os.environ["SPACK_ROOT"] + "/share/spack/lmod"
    theirflav = theirflavor(flavor)
    if not compdashver:
        compdashver = guess_compiler(flavor, quals)
        compiler, compver = compdashver.split("-")

    # convert ups v2_3 to 2.3 etc.
    dotver = version.replace("v", "").replace("b", "").replace("_", ".")

    # note this is Very Important, it's how the spec file actually gets made...
    if not thash:
        thash = get_hash(product, version, flavor, quals, compiler, compver, orig_flav=orig_flav, orig_qual=orig_qual)

    if not thash:
        logging.error(
            "Error: Unable to find hash for product %s %s -f %s -q %s"
            % (product, version, flavor, quals)
        )
        return

    shorthash = thash[:7]

    logging.debug("Handling: %s %s -f %s -q %s\n" % (product, version, flavor, quals))
    logging.info("Converting %s:" % table_file)

    logging.debug("thash: %s, shorthash %s" % (thash, shorthash))

    tclmodulefile = "%s/%s/%s-%s-%s-%s" % (
        tclbase,
        theirflav,
        product,
        dotver,
        compdashver,
        shorthash,
    )
    lmodmodulefile = "%s/%s/Core/%s/%s-%s-%s.lua" % (
        lmodbase,
        theirflav,
        product,
        dotver,
        compdashver,
        shorthash,
    )

    tcl_out = outfile(tclmodulefile)
    tcl_out.enable()
    tcl_out.write(
        """#%%Module1.0

# $product modulefile
# generated by %s 

set version %s
set prefix  %s
"""
        % (sys.argv[0], dotver, prod_dir)
    )
    tcl_out.disable()

    lmod_out = outfile(lmodmodulefile)
    lmod_out.enable()
    lmod_out.write(
        """-- -*- lua -*-
-- Module file created by %s
--

whatis([[Name : %s]])
whatis([[Version : %s]])


"""
        % (sys.argv[0], product, dotver)
    )
    lmod_out.disable()

    flavorok = False
    in_action = False
  
    if table_file:
        tff = open(table_file, "r")
    else:
        tff = open('/dev/null','r')

    for line in tff:

        logging.debug("processing table file line: %s" % line)
        line = line.strip()
        line = fix_ups_vars(line, prod_dir, version)

        # remove comments..
        line = re.sub("\#.*", "", line)

        if re.search("flavor\\s*=\\s*ANY", line, flags=re.IGNORECASE):
            flavorok = True
            continue
        if re.search(
            "flavor\\s*=\\s*%s" % flavor.replace("+", "\\+"), line, flags=re.IGNORECASE
        ):
            flavorok = True
            continue
        if re.search("flavor\\s*=", line, flags=re.IGNORECASE):
            flavorok = False
            continue
        if re.search("qualifiers\\s*=%s" % quals, line, flags=re.IGNORECASE):
            if flavorok:
                lmod_out.enable()
                tcl_out.enable()
            else:
                lmod_out.disable()
                tcl_out.disable()
            continue
        if re.search("common:", line, flags=re.IGNORECASE):
            lmod_out.enable()
            tcl_out.enable()
            continue
        if re.search("action\\s*=", line, flags=re.IGNORECASE):
            if in_action:
                lmod_out.write("end\n\n")
                tcl_out.write("}\n\n")
            in_action = True
            name = re.sub(".*action\\s*=\\s*", "", line, flags=re.IGNORECASE)
            tcl_out.write("proc %s {} {\n" % name)
            lmod_out.write("function %s ()\n" % name)
            continue
        if re.search("exeaction\(", line, flags=re.IGNORECASE):
            d = unpack(line)
            if in_action:
                tcl_out.write(d["var"] + "\n")
                lmod_out.write(d["var"] + "();\n")
            continue
        if re.search("proddir\(|dodefaults", line, flags=re.IGNORECASE):
            if in_action:
                tcl_out.write("setenv %s_DIR %s\n" % (product.upper(), prod_dir))
                tcl_out.write("setenv %s_FQ_DIR %s\n" % (product.upper(), prod_dir))
                lmod_out.write('setenv("%s_DIR","%s");\n' % (product.upper(), prod_dir))
                lmod_out.write(
                    'setenv("%s_FQ_DIR","%s");\n' % (product.upper(), prod_dir)
                )
            continue
        if re.search("envSet\(", line, flags=re.IGNORECASE):
            d = unpack(line)
            if in_action:
                tcl_out.write("setenv %s %s\n" % (d["var"], d["value"]))
                lmod_out.write('setenv("%s","%s");\n' % (d["var"], d["value"]))
            continue
        if re.search("(env|path)prepend", line, flags=re.IGNORECASE):
            d = unpack(line)
            if in_action:
                tcl_out.write("prepend-path %s %s\n" % (d["var"], d["value"]))
                lmod_out.write('prepend_path("%s","%s");\n' % (d["var"], d["value"]))
            continue
        if re.search("setup(required|optional)", line, flags=re.IGNORECASE):
            d = unpack(line)
            if in_action:
                tcl_out.write("module load %s \n" % (convert_dependency(d["args"])))
                lmod_out.write('load("%s");\n' % (convert_dependency(d["args"])))
            continue
        if re.search("addalias", line, flags=re.IGNORECASE):
            d = unpack(line)
            if in_action:
                tcl_out.write("set-alias %s %s\n" % (d["var"], d["value"]))
                lmod_out.write('set_alias("%s","%s");\n' % (d["var"], d["value"]))
            continue

        if re.search("execute", line, flags=re.IGNORECASE):
            d = unpack_execute(line)
            if in_action:
                if d["flags"] == "UPS_ENV":
                    tcl_out.write("setenv UPS_PROD_NAME %s\n" % product)
                    tcl_out.write("setenv UPS_PROD_DIR %s\n" % prod_dir)
                    tcl_out.write("setenv UPS_UPS_DIR %s/ups\n" % prod_dir)
                    tcl_out.write("setenv VERSION %s\n" % dotver)
                    lmod_out.write('setenv("UPS_PROD_NAME","%s");\n' % product)
                    lmod_out.write('setenv("UPS_PROD_DIR","%s");\n' % prod_dir)
                    lmod_out.write('setenv("UPS_UPS_DIR","%s/ups");\n' % prod_dir)
                    lmod_out.write('setenv("VERSION","%s");\n' % dotver)

                if d["envvar"]:
                    tcl_out.write("setenv %s [exec {%s}]\n" % (d["envvar"], d["cmd"]))
                    lmod_out.write('f=io.open("%s");\n' % d["cmd"])
                    lmod_out.write('setenv("%s",f.read());\n' % d["envvar"])
                    lmod_out.write("f.close();\n")

                else:
                    tcl_out.write("exec {%s}\n" % d["cmd"])
                    lmod_out.write('os.execute("%s");\n' % d["cmd"])
                continue

        if re.search("endif", line, flags=re.IGNORECASE):
            if in_action:
                tcl_out.write("}\n\n")
                lmod_out.write("end\n\n")
            continue
        if re.search("else", line, flags=re.IGNORECASE):
            if in_action:
                tcl_out.write("} else {\n")
                lmod_out.write("else\n")
            continue
        if re.search("if", line, flags=re.IGNORECASE):
            d = unpack(line)
            if in_action:
                tcl_out.write("if {![catch {exec %s} results options]} {\n" % d["args"])
                lmod_out.write('if (!os.execute("%s")) then\n' % d["args"])
            continue
        if re.search("end", line, flags=re.IGNORECASE):
            if in_action:
                tcl_out.write("}\n")
                lmod_out.write("end\n")
                in_action = False
            continue

    tcl_out.enable()
    lmod_out.enable()

    if in_action:
        tcl_out.write("}\n")
        lmod_out.write("end\n")

    tcl_out.write("\nsetup\n")
    lmod_out.write("\nsetup();\n")
    tcl_out.close()
    lmod_out.close()

def ups_to_spack(argv):
    global override_os
    override_os = None
    if argv[0] == "-o":
        override_os = argv[1]
        argv = argv[2:]
    if len(argv) == 0:
        print("usage: %s [ups list args]" % sys.argv[0])

    pkgl = parsed_ups_list(argv)

    logging.debug("pkgl: %s" % repr(pkgl))

    rpkgl = parsed_ups_dependencies(pkgl)

    logging.debug("rpkgl: %s" % repr(rpkgl))

    for prod, vers, flavor, quals, prod_dir, table_file, topflavor, topquals, depth in rpkgl:
         if depth == 0 and flavor == "NULL":
             # a toplevel NULL product needs to be declared for everything :-(
             for topflav, topquals in all_flavors:
                 migrate(prod, vers, flavor, quals, prod_dir, table_file, topflavor, topquals)
                 
         else:
             # other products needs to be declared for their toplevel parent's flavor
             migrate(prod, vers, flavor, quals, prod_dir, table_file, topflavor, topquals)


already_done = set()

def migrate(prod, vers, flavor, quals, prod_dir, table_file, topflav, topquals):
    global already_done

    logging.debug("entering migrate%s"% repr((prod, vers, flavor, quals, prod_dir, table_file, topflav, topquals)))
    
    if (prod, vers, flavor, quals, prod_dir, table_file, topflav, topquals) in already_done:
        logging.debug("migrate--already did this one, returning...")
        return
    already_done.add( (prod, vers, flavor, quals, prod_dir, table_file, topflav, topquals) )

    theirflav = theirflavor(topflav)
    dotver = vers.replace("v", "").replace("b", "").replace("_", ".")
    global compdashver, compiler, compver
    compdashver = guess_compiler(topflav, topquals)
    compiler, compver = compdashver.split("-")

    thash = make_spec(prod, vers, dotver, flavor, quals, theirflav, topflav, topquals)
    convert_tablefile(prod, vers, flavor, quals, prod_dir, table_file, topflav, topquals, thash)
    logging.debug("leaving  migrate%s"% repr((prod, vers, flavor, quals, prod_dir, table_file, topflav, topquals)))

def parsed_ups_dependencies(pkgl):
    res = []
    for prod, vers, topflavor, topquals, prod_dir, table_file in pkgl:
        for line in ups_depend(prod, vers, topflavor, topquals):
            line.rstrip()
            m = re.match("^[\|_ ]*", line)
            depth = len(m.group(0))/3
            args = re.sub("^[\|_ ]*","",line).split(" ")
            pul = parsed_ups_list(args)
            if pul:
                res.append( pul[0] + [topflavor, topquals, depth])
    # sort by reverse depth -- deepest dependencies first
    res.sort(key=lambda x: -x[-1])
    return res

def parsed_ups_list(argv):
    ucmd = (
        "ups list -Kproduct:version:flavor:qualifiers:@prod_dir:@table_file "
        + " ".join(argv) + " 2>/dev/null"
    )
    logging.debug("running: %s" % ucmd)
    res = []
    ulf = os.popen(ucmd, "r")
    for line in ulf:
        line = line.rstrip()
        res.append(line.replace('"','').split(" "))
    ulf.close()
    return res


cache_file = os.environ["SPACK_ROOT"] + "/var/ups_to_spack.cache"
logging.basicConfig(level=logging.DEBUG)
ups_to_spack(sys.argv[1:])
