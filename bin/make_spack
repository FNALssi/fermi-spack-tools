#!/bin/bash


spackbindir=`echo $0 | sed -e 's;make_spack;;' `
case x$spackbindir in
x/*) ;;
x*)  spackbindir="$PWD/$spackbindir"
esac

#
# binary cache to use
#

binary_cache=https://spack-cache-1.fnal.gov/binaries/

install_latest() {
    pkg="$1"
    if $use_buildcache
    then 
        hash_pkg_ver=`spack -k buildcache list --long --allarch "$pkg $plat" | tail -1`
        echo "make_spack: info: latest $pkg is $hash_pkg_ver"
        hash=`echo $hash_pkg_ver | sed -e 's/ .*//'`
        spack -k buildcache install -o -a -m "/$hash"
    else
        spack -k install "$pkg $plat"
    fi
}

#
# Spack needs patchelf installed to do binary installs:
# which creates a catch-22 when trying to do a binary install of patchelf.
# However, it turns out we don't *actually* need to patchelf patchelf itself, 
# as it only relies on system libraries.
# So we can lie to spack about there being a system patchelf long enough to
# install patchelf, and then take the lie away.
#
# I have a patch for spack that obviates this... then you can just
# install with spack buildcache install patchelf...
#

bootstrap_patchelf() {
    pf=$SPACK_ROOT/etc/packages.yaml
    if [ -r $pf ] 
    then
       mv $pf $pf.bak$$
    fi

cat > $pf <<EOF
packages:
  patchelf:
    paths:
      patchelf@0.00:
EOF
    mkdir /tmp/.pth$$
    PATH="/tmp/.pth$$:$PATH"
    echo ":" > /tmp/.pth$$/patchelf
    chmod +x /tmp/.pth$$/patchelf

    install_latest patchelf

    rm $pf

    if [ -r $pf.bak$$ ] 
    then
       mv $pf.bak$$ $pf 
    fi
    rm -rf /tmp/.pth$$

    patchelf_dir=`spack find --paths patchelf | tail -1 | sed -e 's/.* //'`
    PATH="$patchelf_dir/bin:$PATH"
}

find_compilers() {
   spack compiler find --scope=site
}

bootstrap_spack() {
    bootstrap_patchelf
    find_compilers
    if echo $spack_release | grep rollout > /dev/null
    then
        install_latest environment-modules
        install_latest lmod
    fi
    if $minimal
    then
        :
    else
        install_latest py-machotools
    fi
    make_packages_yaml $SPACK_ROOT
}

add_recipe_repos() {
    git clone https://cdcvs.fnal.gov/projects/spack-planning-spack_art $SPACK_ROOT/var/spack/repos/fnal_art
    spack repo add --scope=site $SPACK_ROOT/var/spack/repos/fnal_art

    git clone https://cdcvs.fnal.gov/projects/spack-infrastructure-scd_recipes $SPACK_ROOT/var/spack/repos/scd_recipes
    spack repo add --scope=site $SPACK_ROOT/var/spack/repos/scd_recipes

    spack repo create $SPACK_ROOT/var/spack/repos/ups_to_spack
    spack repo add --scope=site $SPACK_ROOT/var/spack/repos/ups_to_spack
}

create_spack() {
    d=`dirname $SPACK_ROOT`
    b=`basename $SPACK_ROOT`
    mkdir -p $d
    if cd $d
    then 
        case "$spack_root" in
        *github.com*) args="--depth 4" ;;
        *) args="";;
        esac
        git clone $args  -b $spack_release $spack_repo $b

        if cd $b
        then 
            echo "make_spack: INFO: running: $add_config"
            $add_config
            export plat="target=`uname -i` os=`spack arch --operating-system`"
            spack mirror add --scope site fnal $binary_cache
            spack -k buildcache keys --install --trust --force
            add_recipe_repos
            if $upgrading
            then
                spack reindex
            else
                bootstrap_spack
            fi
        else
            echo "echo make_spack: ERROR: Unable to git clone $spack_repo as $b" >&2
            echo "FAILED"
            exit 1
        fi
    else
        echo "make_spack: ERROR: Unable to make/change directories to $d" >&2
        echo "FAILED"
        exit 1
    fi
}

make_absolute() {
   case x$1 in
   x.)   echo $PWD;;
   x./*) echo $PWD/$1;;
   x/*)  echo $1;;
   *)    echo $PWD/$1;;
   esac
}

#
# where to git clone spack from, and what branch/release
#
#spack_repo=https://cdcvs.fnal.gov/projects/spack-infrastructure-spack
spack_repo=https://github.com/marcmengel/spack.git

#spack_release=rollout
#spack_release=rollout2
spack_release=v0.16.1.fermi
use_buildcache=true
minimal=false
upgrading=false

while echo x$1 | grep x-- > /dev/null
do
    case "x$1" in
    x--upgrade)
       upgrading=true
       shift
       ;;
    x--spack_release)
       spack_release=$2
       shift; shift
       ;;
    x--minimal)
       minimal=true
       shift
       ;;
    x--no-buildcache)
       use_buildcache=false
       shift
       ;;
    *)
        echo "unknown option $1"
        shift
        exit
        ;;
    esac
done


case "$spack_release" in
rollout*) extra="";;
*)        extra=".new";;
esac

if [ "x$1" = "x-p" ]
then
    echo "make_spack: INFO: Setting up for plain spack..."
    export SPACK_ROOT=`make_absolute $2`
    mkdir -p "$SPACK_ROOT" 
    if [ ! -d "$SPACK_ROOT" -o ! -w "$SPACK_ROOT" ]
    then
        echo "make_spack: ERROR: Unable to make writable directory '$SPACK_ROOT'" >&2
        echo "FAILED" >&2
        exit 1
    fi
    add_config=:
elif [ "x$1" = "x-t" ]
then
    echo "make_spack: INFO: setting up for traditional ups layout under $2"
    do_setup_env=true
    dir=`make_absolute "$2"`
    mkdir -p "$dir" 
    if [ ! -d "$dir" -o ! -w "$dir" ]
    then
        echo "make_spack: ERROR: Unable to make writable directory '$dir'" >&2
        echo "FAILED" >&2
        exit 1
    fi
    export SPACK_ROOT=$dir/prd/spack/$spack_release/NULL
    export add_config="cp $spackbindir/../templates/config.yaml.traditional${extra} $SPACK_ROOT/etc/spack/config.yaml"
elif [ "x$1" = "x-u"  ]
then
    echo "make_spack: INFO: setting up for unified layout under $dir"
    do_setup_env=true
    dir=`make_absolute "$2"`
    mkdir -p "$dir" 
    if [ ! -d "$dir" -o ! -w "$dir" ]
    then
        echo "make_spack: ERROR: Unable to make writable directory '$dir'" >&2
        echo "FAILED" >&2
        exit 1
    fi
    export SPACK_ROOT=$dir/spack/$spack_release/NULL
    export add_config="cp $spackbindir/../templates/config.yaml.unified${extra} $SPACK_ROOT/etc/spack/config.yaml"
else
    echo "Usage: $0 [options] -[utp] /base/directory"
    echo " options:"
    echo "  --upgrade"
    echo "  --no-buildcache"
    echo "  --spack_release ver"
    echo "  --minimal"
    echo "  make a spack instance with given layout"
    echo "  -u fermi 'unified' layout"
    echo "  -t fermi 'traditional' layout"
    echo "  -p plain spack default layout"
    echo "  -m minimal setup"
    exit 1
fi

export PATH=$SPACK_ROOT/bin:$PATH
create_spack

# save setup-env creation/update till the end so if we're upgrading and it
# dies, we don't change it until the end.

if $do_setup_env
then
    echo ". $SPACK_ROOT/share/spack/setup-env.sh" > $dir/setup-env.sh
    echo "source $SPACK_ROOT/share/spack/setup-env.csh" > $dir/setup-env.csh
fi
